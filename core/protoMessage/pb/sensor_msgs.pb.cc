// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensor_msgs.proto

#include "sensor_msgs.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace sensor_msgs {
PROTOBUF_CONSTEXPR Twist2D::Twist2D(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.v_x_)*/0
  , /*decltype(_impl_.v_y_)*/0
  , /*decltype(_impl_.omega_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Twist2DDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Twist2DDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Twist2DDefaultTypeInternal() {}
  union {
    Twist2D _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Twist2DDefaultTypeInternal _Twist2D_default_instance_;
PROTOBUF_CONSTEXPR Twist2DStamp::Twist2DStamp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.twist_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Twist2DStampDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Twist2DStampDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Twist2DStampDefaultTypeInternal() {}
  union {
    Twist2DStamp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Twist2DStampDefaultTypeInternal _Twist2DStamp_default_instance_;
PROTOBUF_CONSTEXPR PointCloud2f::PointCloud2f(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.points_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PointCloud2fDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PointCloud2fDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PointCloud2fDefaultTypeInternal() {}
  union {
    PointCloud2f _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PointCloud2fDefaultTypeInternal _PointCloud2f_default_instance_;
PROTOBUF_CONSTEXPR PointCloud3f::PointCloud3f(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.points_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PointCloud3fDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PointCloud3fDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PointCloud3fDefaultTypeInternal() {}
  union {
    PointCloud3f _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PointCloud3fDefaultTypeInternal _PointCloud3f_default_instance_;
PROTOBUF_CONSTEXPR LaserScan::LaserScan(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ranges_)*/{}
  , /*decltype(_impl_.intensities_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.anglemin_)*/0
  , /*decltype(_impl_.anglemax_)*/0
  , /*decltype(_impl_.angleincrement_)*/0
  , /*decltype(_impl_.timeincrement_)*/0
  , /*decltype(_impl_.scantime_)*/0
  , /*decltype(_impl_.rangemin_)*/0
  , /*decltype(_impl_.rangemax_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LaserScanDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LaserScanDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LaserScanDefaultTypeInternal() {}
  union {
    LaserScan _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LaserScanDefaultTypeInternal _LaserScan_default_instance_;
PROTOBUF_CONSTEXPR Imu::Imu(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.angularvelocity_)*/nullptr
  , /*decltype(_impl_.linearacceleration_)*/nullptr
  , /*decltype(_impl_.magnetometerdata_)*/nullptr
  , /*decltype(_impl_.euler_)*/nullptr
  , /*decltype(_impl_.orientation_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ImuDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ImuDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ImuDefaultTypeInternal() {}
  union {
    Imu _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ImuDefaultTypeInternal _Imu_default_instance_;
PROTOBUF_CONSTEXPR Odometry::Odometry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.childframeid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.angular_)*/nullptr
  , /*decltype(_impl_.linearacceleration_)*/nullptr
  , /*decltype(_impl_.angularvelocity_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OdometryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OdometryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OdometryDefaultTypeInternal() {}
  union {
    Odometry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OdometryDefaultTypeInternal _Odometry_default_instance_;
PROTOBUF_CONSTEXPR OccupancyMap::OccupancyMap(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.data_)*/{}
  , /*decltype(_impl_._data_cached_byte_size_)*/{0}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.resolution_)*/0
  , /*decltype(_impl_.width_)*/0
  , /*decltype(_impl_.height_)*/0
  , /*decltype(_impl_.origin_x_)*/0
  , /*decltype(_impl_.origin_y_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OccupancyMapDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OccupancyMapDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OccupancyMapDefaultTypeInternal() {}
  union {
    OccupancyMap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OccupancyMapDefaultTypeInternal _OccupancyMap_default_instance_;
PROTOBUF_CONSTEXPR ESDFMap::ESDFMap(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.points_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ESDFMapDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ESDFMapDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ESDFMapDefaultTypeInternal() {}
  union {
    ESDFMap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ESDFMapDefaultTypeInternal _ESDFMap_default_instance_;
}  // namespace sensor_msgs
static ::_pb::Metadata file_level_metadata_sensor_5fmsgs_2eproto[9];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_sensor_5fmsgs_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_sensor_5fmsgs_2eproto = nullptr;

const uint32_t TableStruct_sensor_5fmsgs_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::Twist2D, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::Twist2D, _impl_.v_x_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::Twist2D, _impl_.v_y_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::Twist2D, _impl_.omega_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::Twist2DStamp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::Twist2DStamp, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::Twist2DStamp, _impl_.twist_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::PointCloud2f, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::PointCloud2f, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::PointCloud2f, _impl_.points_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::PointCloud3f, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::PointCloud3f, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::PointCloud3f, _impl_.points_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::LaserScan, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::LaserScan, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::LaserScan, _impl_.anglemin_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::LaserScan, _impl_.anglemax_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::LaserScan, _impl_.angleincrement_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::LaserScan, _impl_.timeincrement_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::LaserScan, _impl_.scantime_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::LaserScan, _impl_.rangemin_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::LaserScan, _impl_.rangemax_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::LaserScan, _impl_.ranges_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::LaserScan, _impl_.intensities_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::Imu, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::Imu, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::Imu, _impl_.angularvelocity_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::Imu, _impl_.linearacceleration_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::Imu, _impl_.magnetometerdata_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::Imu, _impl_.euler_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::Imu, _impl_.orientation_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::Odometry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::Odometry, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::Odometry, _impl_.childframeid_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::Odometry, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::Odometry, _impl_.angular_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::Odometry, _impl_.linearacceleration_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::Odometry, _impl_.angularvelocity_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::OccupancyMap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::OccupancyMap, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::OccupancyMap, _impl_.resolution_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::OccupancyMap, _impl_.width_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::OccupancyMap, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::OccupancyMap, _impl_.origin_x_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::OccupancyMap, _impl_.origin_y_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::OccupancyMap, _impl_.data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::ESDFMap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::ESDFMap, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::sensor_msgs::ESDFMap, _impl_.points_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::sensor_msgs::Twist2D)},
  { 9, -1, -1, sizeof(::sensor_msgs::Twist2DStamp)},
  { 17, -1, -1, sizeof(::sensor_msgs::PointCloud2f)},
  { 25, -1, -1, sizeof(::sensor_msgs::PointCloud3f)},
  { 33, -1, -1, sizeof(::sensor_msgs::LaserScan)},
  { 49, -1, -1, sizeof(::sensor_msgs::Imu)},
  { 61, -1, -1, sizeof(::sensor_msgs::Odometry)},
  { 73, -1, -1, sizeof(::sensor_msgs::OccupancyMap)},
  { 86, -1, -1, sizeof(::sensor_msgs::ESDFMap)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::sensor_msgs::_Twist2D_default_instance_._instance,
  &::sensor_msgs::_Twist2DStamp_default_instance_._instance,
  &::sensor_msgs::_PointCloud2f_default_instance_._instance,
  &::sensor_msgs::_PointCloud3f_default_instance_._instance,
  &::sensor_msgs::_LaserScan_default_instance_._instance,
  &::sensor_msgs::_Imu_default_instance_._instance,
  &::sensor_msgs::_Odometry_default_instance_._instance,
  &::sensor_msgs::_OccupancyMap_default_instance_._instance,
  &::sensor_msgs::_ESDFMap_default_instance_._instance,
};

const char descriptor_table_protodef_sensor_5fmsgs_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\021sensor_msgs.proto\022\013sensor_msgs\032\016std_ms"
  "gs.proto\"2\n\007Twist2D\022\013\n\003v_x\030\001 \001(\002\022\013\n\003v_y\030"
  "\002 \001(\002\022\r\n\005omega\030\003 \001(\002\"U\n\014Twist2DStamp\022 \n\006"
  "header\030\001 \001(\0132\020.std_msgs.Header\022#\n\005twist\030"
  "\002 \001(\0132\024.sensor_msgs.Twist2D\"T\n\014PointClou"
  "d2f\022 \n\006header\030\001 \001(\0132\020.std_msgs.Header\022\"\n"
  "\006points\030\002 \001(\0132\022.std_msgs.Vector2f\"T\n\014Poi"
  "ntCloud3f\022 \n\006header\030\001 \001(\0132\020.std_msgs.Hea"
  "der\022\"\n\006points\030\002 \001(\0132\022.std_msgs.Vector3f\""
  "\333\001\n\tLaserScan\022 \n\006header\030\001 \001(\0132\020.std_msgs"
  ".Header\022\020\n\010angleMin\030\002 \001(\002\022\020\n\010angleMax\030\003 "
  "\001(\002\022\026\n\016angleIncrement\030\004 \001(\002\022\025\n\rtimeIncre"
  "ment\030\005 \001(\002\022\020\n\010scanTime\030\006 \001(\002\022\020\n\010rangeMin"
  "\030\007 \001(\002\022\020\n\010rangeMax\030\010 \001(\002\022\016\n\006ranges\030\t \003(\002"
  "\022\023\n\013intensities\030\n \003(\002\"\201\002\n\003Imu\022 \n\006header\030"
  "\001 \001(\0132\020.std_msgs.Header\022+\n\017angularVeloci"
  "ty\030\002 \001(\0132\022.std_msgs.Vector3f\022.\n\022linearAc"
  "celeration\030\003 \001(\0132\022.std_msgs.Vector3f\022,\n\020"
  "magnetometerData\030\004 \001(\0132\022.std_msgs.Vector"
  "3f\022!\n\005euler\030\005 \001(\0132\022.std_msgs.Vector3f\022*\n"
  "\013orientation\030\006 \001(\0132\025.std_msgs.Quaternion"
  "f\"\352\001\n\010Odometry\022 \n\006header\030\001 \001(\0132\020.std_msg"
  "s.Header\022\024\n\014childFrameId\030\002 \001(\t\022$\n\010positi"
  "on\030\003 \001(\0132\022.std_msgs.Vector3f\022#\n\007angular\030"
  "\004 \001(\0132\022.std_msgs.Vector3f\022.\n\022linearAccel"
  "eration\030\005 \001(\0132\022.std_msgs.Vector3f\022+\n\017ang"
  "ularVelocity\030\006 \001(\0132\022.std_msgs.Vector3f\"\225"
  "\001\n\014OccupancyMap\022 \n\006header\030\001 \001(\0132\020.std_ms"
  "gs.Header\022\022\n\nresolution\030\002 \001(\002\022\r\n\005width\030\003"
  " \001(\005\022\016\n\006height\030\004 \001(\005\022\020\n\010origin_x\030\005 \001(\002\022\020"
  "\n\010origin_y\030\006 \001(\002\022\014\n\004data\030\007 \003(\005\"O\n\007ESDFMa"
  "p\022 \n\006header\030\001 \001(\0132\020.std_msgs.Header\022\"\n\006p"
  "oints\030\002 \003(\0132\022.std_msgs.Vector4fb\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_sensor_5fmsgs_2eproto_deps[1] = {
  &::descriptor_table_std_5fmsgs_2eproto,
};
static ::_pbi::once_flag descriptor_table_sensor_5fmsgs_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_sensor_5fmsgs_2eproto = {
    false, false, 1319, descriptor_table_protodef_sensor_5fmsgs_2eproto,
    "sensor_msgs.proto",
    &descriptor_table_sensor_5fmsgs_2eproto_once, descriptor_table_sensor_5fmsgs_2eproto_deps, 1, 9,
    schemas, file_default_instances, TableStruct_sensor_5fmsgs_2eproto::offsets,
    file_level_metadata_sensor_5fmsgs_2eproto, file_level_enum_descriptors_sensor_5fmsgs_2eproto,
    file_level_service_descriptors_sensor_5fmsgs_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_sensor_5fmsgs_2eproto_getter() {
  return &descriptor_table_sensor_5fmsgs_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_sensor_5fmsgs_2eproto(&descriptor_table_sensor_5fmsgs_2eproto);
namespace sensor_msgs {

// ===================================================================

class Twist2D::_Internal {
 public:
};

Twist2D::Twist2D(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:sensor_msgs.Twist2D)
}
Twist2D::Twist2D(const Twist2D& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Twist2D* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.v_x_){}
    , decltype(_impl_.v_y_){}
    , decltype(_impl_.omega_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.v_x_, &from._impl_.v_x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.omega_) -
    reinterpret_cast<char*>(&_impl_.v_x_)) + sizeof(_impl_.omega_));
  // @@protoc_insertion_point(copy_constructor:sensor_msgs.Twist2D)
}

inline void Twist2D::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.v_x_){0}
    , decltype(_impl_.v_y_){0}
    , decltype(_impl_.omega_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Twist2D::~Twist2D() {
  // @@protoc_insertion_point(destructor:sensor_msgs.Twist2D)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Twist2D::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Twist2D::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Twist2D::Clear() {
// @@protoc_insertion_point(message_clear_start:sensor_msgs.Twist2D)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.v_x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.omega_) -
      reinterpret_cast<char*>(&_impl_.v_x_)) + sizeof(_impl_.omega_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Twist2D::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float v_x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.v_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float v_y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.v_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float omega = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.omega_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Twist2D::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensor_msgs.Twist2D)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float v_x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_v_x = this->_internal_v_x();
  uint32_t raw_v_x;
  memcpy(&raw_v_x, &tmp_v_x, sizeof(tmp_v_x));
  if (raw_v_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_v_x(), target);
  }

  // float v_y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_v_y = this->_internal_v_y();
  uint32_t raw_v_y;
  memcpy(&raw_v_y, &tmp_v_y, sizeof(tmp_v_y));
  if (raw_v_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_v_y(), target);
  }

  // float omega = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_omega = this->_internal_omega();
  uint32_t raw_omega;
  memcpy(&raw_omega, &tmp_omega, sizeof(tmp_omega));
  if (raw_omega != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_omega(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensor_msgs.Twist2D)
  return target;
}

size_t Twist2D::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensor_msgs.Twist2D)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float v_x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_v_x = this->_internal_v_x();
  uint32_t raw_v_x;
  memcpy(&raw_v_x, &tmp_v_x, sizeof(tmp_v_x));
  if (raw_v_x != 0) {
    total_size += 1 + 4;
  }

  // float v_y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_v_y = this->_internal_v_y();
  uint32_t raw_v_y;
  memcpy(&raw_v_y, &tmp_v_y, sizeof(tmp_v_y));
  if (raw_v_y != 0) {
    total_size += 1 + 4;
  }

  // float omega = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_omega = this->_internal_omega();
  uint32_t raw_omega;
  memcpy(&raw_omega, &tmp_omega, sizeof(tmp_omega));
  if (raw_omega != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Twist2D::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Twist2D::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Twist2D::GetClassData() const { return &_class_data_; }


void Twist2D::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Twist2D*>(&to_msg);
  auto& from = static_cast<const Twist2D&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensor_msgs.Twist2D)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_v_x = from._internal_v_x();
  uint32_t raw_v_x;
  memcpy(&raw_v_x, &tmp_v_x, sizeof(tmp_v_x));
  if (raw_v_x != 0) {
    _this->_internal_set_v_x(from._internal_v_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_v_y = from._internal_v_y();
  uint32_t raw_v_y;
  memcpy(&raw_v_y, &tmp_v_y, sizeof(tmp_v_y));
  if (raw_v_y != 0) {
    _this->_internal_set_v_y(from._internal_v_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_omega = from._internal_omega();
  uint32_t raw_omega;
  memcpy(&raw_omega, &tmp_omega, sizeof(tmp_omega));
  if (raw_omega != 0) {
    _this->_internal_set_omega(from._internal_omega());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Twist2D::CopyFrom(const Twist2D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensor_msgs.Twist2D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Twist2D::IsInitialized() const {
  return true;
}

void Twist2D::InternalSwap(Twist2D* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Twist2D, _impl_.omega_)
      + sizeof(Twist2D::_impl_.omega_)
      - PROTOBUF_FIELD_OFFSET(Twist2D, _impl_.v_x_)>(
          reinterpret_cast<char*>(&_impl_.v_x_),
          reinterpret_cast<char*>(&other->_impl_.v_x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Twist2D::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensor_5fmsgs_2eproto_getter, &descriptor_table_sensor_5fmsgs_2eproto_once,
      file_level_metadata_sensor_5fmsgs_2eproto[0]);
}

// ===================================================================

class Twist2DStamp::_Internal {
 public:
  static const ::std_msgs::Header& header(const Twist2DStamp* msg);
  static const ::sensor_msgs::Twist2D& twist(const Twist2DStamp* msg);
};

const ::std_msgs::Header&
Twist2DStamp::_Internal::header(const Twist2DStamp* msg) {
  return *msg->_impl_.header_;
}
const ::sensor_msgs::Twist2D&
Twist2DStamp::_Internal::twist(const Twist2DStamp* msg) {
  return *msg->_impl_.twist_;
}
void Twist2DStamp::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
Twist2DStamp::Twist2DStamp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:sensor_msgs.Twist2DStamp)
}
Twist2DStamp::Twist2DStamp(const Twist2DStamp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Twist2DStamp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.twist_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::std_msgs::Header(*from._impl_.header_);
  }
  if (from._internal_has_twist()) {
    _this->_impl_.twist_ = new ::sensor_msgs::Twist2D(*from._impl_.twist_);
  }
  // @@protoc_insertion_point(copy_constructor:sensor_msgs.Twist2DStamp)
}

inline void Twist2DStamp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.twist_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Twist2DStamp::~Twist2DStamp() {
  // @@protoc_insertion_point(destructor:sensor_msgs.Twist2DStamp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Twist2DStamp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.twist_;
}

void Twist2DStamp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Twist2DStamp::Clear() {
// @@protoc_insertion_point(message_clear_start:sensor_msgs.Twist2DStamp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.twist_ != nullptr) {
    delete _impl_.twist_;
  }
  _impl_.twist_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Twist2DStamp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .std_msgs.Header header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .sensor_msgs.Twist2D twist = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_twist(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Twist2DStamp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensor_msgs.Twist2DStamp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .std_msgs.Header header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // .sensor_msgs.Twist2D twist = 2;
  if (this->_internal_has_twist()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::twist(this),
        _Internal::twist(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensor_msgs.Twist2DStamp)
  return target;
}

size_t Twist2DStamp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensor_msgs.Twist2DStamp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .std_msgs.Header header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // .sensor_msgs.Twist2D twist = 2;
  if (this->_internal_has_twist()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.twist_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Twist2DStamp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Twist2DStamp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Twist2DStamp::GetClassData() const { return &_class_data_; }


void Twist2DStamp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Twist2DStamp*>(&to_msg);
  auto& from = static_cast<const Twist2DStamp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensor_msgs.Twist2DStamp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::std_msgs::Header::MergeFrom(
        from._internal_header());
  }
  if (from._internal_has_twist()) {
    _this->_internal_mutable_twist()->::sensor_msgs::Twist2D::MergeFrom(
        from._internal_twist());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Twist2DStamp::CopyFrom(const Twist2DStamp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensor_msgs.Twist2DStamp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Twist2DStamp::IsInitialized() const {
  return true;
}

void Twist2DStamp::InternalSwap(Twist2DStamp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Twist2DStamp, _impl_.twist_)
      + sizeof(Twist2DStamp::_impl_.twist_)
      - PROTOBUF_FIELD_OFFSET(Twist2DStamp, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Twist2DStamp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensor_5fmsgs_2eproto_getter, &descriptor_table_sensor_5fmsgs_2eproto_once,
      file_level_metadata_sensor_5fmsgs_2eproto[1]);
}

// ===================================================================

class PointCloud2f::_Internal {
 public:
  static const ::std_msgs::Header& header(const PointCloud2f* msg);
  static const ::std_msgs::Vector2f& points(const PointCloud2f* msg);
};

const ::std_msgs::Header&
PointCloud2f::_Internal::header(const PointCloud2f* msg) {
  return *msg->_impl_.header_;
}
const ::std_msgs::Vector2f&
PointCloud2f::_Internal::points(const PointCloud2f* msg) {
  return *msg->_impl_.points_;
}
void PointCloud2f::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
void PointCloud2f::clear_points() {
  if (GetArenaForAllocation() == nullptr && _impl_.points_ != nullptr) {
    delete _impl_.points_;
  }
  _impl_.points_ = nullptr;
}
PointCloud2f::PointCloud2f(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:sensor_msgs.PointCloud2f)
}
PointCloud2f::PointCloud2f(const PointCloud2f& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PointCloud2f* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.points_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::std_msgs::Header(*from._impl_.header_);
  }
  if (from._internal_has_points()) {
    _this->_impl_.points_ = new ::std_msgs::Vector2f(*from._impl_.points_);
  }
  // @@protoc_insertion_point(copy_constructor:sensor_msgs.PointCloud2f)
}

inline void PointCloud2f::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.points_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PointCloud2f::~PointCloud2f() {
  // @@protoc_insertion_point(destructor:sensor_msgs.PointCloud2f)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PointCloud2f::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.points_;
}

void PointCloud2f::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PointCloud2f::Clear() {
// @@protoc_insertion_point(message_clear_start:sensor_msgs.PointCloud2f)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.points_ != nullptr) {
    delete _impl_.points_;
  }
  _impl_.points_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PointCloud2f::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .std_msgs.Header header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .std_msgs.Vector2f points = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_points(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PointCloud2f::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensor_msgs.PointCloud2f)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .std_msgs.Header header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // .std_msgs.Vector2f points = 2;
  if (this->_internal_has_points()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::points(this),
        _Internal::points(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensor_msgs.PointCloud2f)
  return target;
}

size_t PointCloud2f::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensor_msgs.PointCloud2f)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .std_msgs.Header header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // .std_msgs.Vector2f points = 2;
  if (this->_internal_has_points()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.points_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PointCloud2f::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PointCloud2f::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PointCloud2f::GetClassData() const { return &_class_data_; }


void PointCloud2f::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PointCloud2f*>(&to_msg);
  auto& from = static_cast<const PointCloud2f&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensor_msgs.PointCloud2f)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::std_msgs::Header::MergeFrom(
        from._internal_header());
  }
  if (from._internal_has_points()) {
    _this->_internal_mutable_points()->::std_msgs::Vector2f::MergeFrom(
        from._internal_points());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PointCloud2f::CopyFrom(const PointCloud2f& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensor_msgs.PointCloud2f)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointCloud2f::IsInitialized() const {
  return true;
}

void PointCloud2f::InternalSwap(PointCloud2f* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PointCloud2f, _impl_.points_)
      + sizeof(PointCloud2f::_impl_.points_)
      - PROTOBUF_FIELD_OFFSET(PointCloud2f, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PointCloud2f::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensor_5fmsgs_2eproto_getter, &descriptor_table_sensor_5fmsgs_2eproto_once,
      file_level_metadata_sensor_5fmsgs_2eproto[2]);
}

// ===================================================================

class PointCloud3f::_Internal {
 public:
  static const ::std_msgs::Header& header(const PointCloud3f* msg);
  static const ::std_msgs::Vector3f& points(const PointCloud3f* msg);
};

const ::std_msgs::Header&
PointCloud3f::_Internal::header(const PointCloud3f* msg) {
  return *msg->_impl_.header_;
}
const ::std_msgs::Vector3f&
PointCloud3f::_Internal::points(const PointCloud3f* msg) {
  return *msg->_impl_.points_;
}
void PointCloud3f::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
void PointCloud3f::clear_points() {
  if (GetArenaForAllocation() == nullptr && _impl_.points_ != nullptr) {
    delete _impl_.points_;
  }
  _impl_.points_ = nullptr;
}
PointCloud3f::PointCloud3f(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:sensor_msgs.PointCloud3f)
}
PointCloud3f::PointCloud3f(const PointCloud3f& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PointCloud3f* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.points_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::std_msgs::Header(*from._impl_.header_);
  }
  if (from._internal_has_points()) {
    _this->_impl_.points_ = new ::std_msgs::Vector3f(*from._impl_.points_);
  }
  // @@protoc_insertion_point(copy_constructor:sensor_msgs.PointCloud3f)
}

inline void PointCloud3f::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.points_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PointCloud3f::~PointCloud3f() {
  // @@protoc_insertion_point(destructor:sensor_msgs.PointCloud3f)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PointCloud3f::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.points_;
}

void PointCloud3f::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PointCloud3f::Clear() {
// @@protoc_insertion_point(message_clear_start:sensor_msgs.PointCloud3f)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.points_ != nullptr) {
    delete _impl_.points_;
  }
  _impl_.points_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PointCloud3f::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .std_msgs.Header header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .std_msgs.Vector3f points = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_points(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PointCloud3f::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensor_msgs.PointCloud3f)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .std_msgs.Header header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // .std_msgs.Vector3f points = 2;
  if (this->_internal_has_points()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::points(this),
        _Internal::points(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensor_msgs.PointCloud3f)
  return target;
}

size_t PointCloud3f::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensor_msgs.PointCloud3f)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .std_msgs.Header header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // .std_msgs.Vector3f points = 2;
  if (this->_internal_has_points()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.points_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PointCloud3f::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PointCloud3f::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PointCloud3f::GetClassData() const { return &_class_data_; }


void PointCloud3f::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PointCloud3f*>(&to_msg);
  auto& from = static_cast<const PointCloud3f&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensor_msgs.PointCloud3f)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::std_msgs::Header::MergeFrom(
        from._internal_header());
  }
  if (from._internal_has_points()) {
    _this->_internal_mutable_points()->::std_msgs::Vector3f::MergeFrom(
        from._internal_points());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PointCloud3f::CopyFrom(const PointCloud3f& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensor_msgs.PointCloud3f)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointCloud3f::IsInitialized() const {
  return true;
}

void PointCloud3f::InternalSwap(PointCloud3f* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PointCloud3f, _impl_.points_)
      + sizeof(PointCloud3f::_impl_.points_)
      - PROTOBUF_FIELD_OFFSET(PointCloud3f, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PointCloud3f::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensor_5fmsgs_2eproto_getter, &descriptor_table_sensor_5fmsgs_2eproto_once,
      file_level_metadata_sensor_5fmsgs_2eproto[3]);
}

// ===================================================================

class LaserScan::_Internal {
 public:
  static const ::std_msgs::Header& header(const LaserScan* msg);
};

const ::std_msgs::Header&
LaserScan::_Internal::header(const LaserScan* msg) {
  return *msg->_impl_.header_;
}
void LaserScan::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
LaserScan::LaserScan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:sensor_msgs.LaserScan)
}
LaserScan::LaserScan(const LaserScan& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LaserScan* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ranges_){from._impl_.ranges_}
    , decltype(_impl_.intensities_){from._impl_.intensities_}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.anglemin_){}
    , decltype(_impl_.anglemax_){}
    , decltype(_impl_.angleincrement_){}
    , decltype(_impl_.timeincrement_){}
    , decltype(_impl_.scantime_){}
    , decltype(_impl_.rangemin_){}
    , decltype(_impl_.rangemax_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::std_msgs::Header(*from._impl_.header_);
  }
  ::memcpy(&_impl_.anglemin_, &from._impl_.anglemin_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.rangemax_) -
    reinterpret_cast<char*>(&_impl_.anglemin_)) + sizeof(_impl_.rangemax_));
  // @@protoc_insertion_point(copy_constructor:sensor_msgs.LaserScan)
}

inline void LaserScan::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ranges_){arena}
    , decltype(_impl_.intensities_){arena}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.anglemin_){0}
    , decltype(_impl_.anglemax_){0}
    , decltype(_impl_.angleincrement_){0}
    , decltype(_impl_.timeincrement_){0}
    , decltype(_impl_.scantime_){0}
    , decltype(_impl_.rangemin_){0}
    , decltype(_impl_.rangemax_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LaserScan::~LaserScan() {
  // @@protoc_insertion_point(destructor:sensor_msgs.LaserScan)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LaserScan::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ranges_.~RepeatedField();
  _impl_.intensities_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void LaserScan::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LaserScan::Clear() {
// @@protoc_insertion_point(message_clear_start:sensor_msgs.LaserScan)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ranges_.Clear();
  _impl_.intensities_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  ::memset(&_impl_.anglemin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.rangemax_) -
      reinterpret_cast<char*>(&_impl_.anglemin_)) + sizeof(_impl_.rangemax_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LaserScan::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .std_msgs.Header header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float angleMin = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.anglemin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float angleMax = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.anglemax_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float angleIncrement = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.angleincrement_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float timeIncrement = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _impl_.timeincrement_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float scanTime = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _impl_.scantime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float rangeMin = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _impl_.rangemin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float rangeMax = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _impl_.rangemax_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated float ranges = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_ranges(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 77) {
          _internal_add_ranges(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated float intensities = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_intensities(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 85) {
          _internal_add_intensities(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LaserScan::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensor_msgs.LaserScan)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .std_msgs.Header header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // float angleMin = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_anglemin = this->_internal_anglemin();
  uint32_t raw_anglemin;
  memcpy(&raw_anglemin, &tmp_anglemin, sizeof(tmp_anglemin));
  if (raw_anglemin != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_anglemin(), target);
  }

  // float angleMax = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_anglemax = this->_internal_anglemax();
  uint32_t raw_anglemax;
  memcpy(&raw_anglemax, &tmp_anglemax, sizeof(tmp_anglemax));
  if (raw_anglemax != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_anglemax(), target);
  }

  // float angleIncrement = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_angleincrement = this->_internal_angleincrement();
  uint32_t raw_angleincrement;
  memcpy(&raw_angleincrement, &tmp_angleincrement, sizeof(tmp_angleincrement));
  if (raw_angleincrement != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_angleincrement(), target);
  }

  // float timeIncrement = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_timeincrement = this->_internal_timeincrement();
  uint32_t raw_timeincrement;
  memcpy(&raw_timeincrement, &tmp_timeincrement, sizeof(tmp_timeincrement));
  if (raw_timeincrement != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_timeincrement(), target);
  }

  // float scanTime = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scantime = this->_internal_scantime();
  uint32_t raw_scantime;
  memcpy(&raw_scantime, &tmp_scantime, sizeof(tmp_scantime));
  if (raw_scantime != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_scantime(), target);
  }

  // float rangeMin = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rangemin = this->_internal_rangemin();
  uint32_t raw_rangemin;
  memcpy(&raw_rangemin, &tmp_rangemin, sizeof(tmp_rangemin));
  if (raw_rangemin != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_rangemin(), target);
  }

  // float rangeMax = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rangemax = this->_internal_rangemax();
  uint32_t raw_rangemax;
  memcpy(&raw_rangemax, &tmp_rangemax, sizeof(tmp_rangemax));
  if (raw_rangemax != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_rangemax(), target);
  }

  // repeated float ranges = 9;
  if (this->_internal_ranges_size() > 0) {
    target = stream->WriteFixedPacked(9, _internal_ranges(), target);
  }

  // repeated float intensities = 10;
  if (this->_internal_intensities_size() > 0) {
    target = stream->WriteFixedPacked(10, _internal_intensities(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensor_msgs.LaserScan)
  return target;
}

size_t LaserScan::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensor_msgs.LaserScan)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float ranges = 9;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_ranges_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float intensities = 10;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_intensities_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // .std_msgs.Header header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // float angleMin = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_anglemin = this->_internal_anglemin();
  uint32_t raw_anglemin;
  memcpy(&raw_anglemin, &tmp_anglemin, sizeof(tmp_anglemin));
  if (raw_anglemin != 0) {
    total_size += 1 + 4;
  }

  // float angleMax = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_anglemax = this->_internal_anglemax();
  uint32_t raw_anglemax;
  memcpy(&raw_anglemax, &tmp_anglemax, sizeof(tmp_anglemax));
  if (raw_anglemax != 0) {
    total_size += 1 + 4;
  }

  // float angleIncrement = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_angleincrement = this->_internal_angleincrement();
  uint32_t raw_angleincrement;
  memcpy(&raw_angleincrement, &tmp_angleincrement, sizeof(tmp_angleincrement));
  if (raw_angleincrement != 0) {
    total_size += 1 + 4;
  }

  // float timeIncrement = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_timeincrement = this->_internal_timeincrement();
  uint32_t raw_timeincrement;
  memcpy(&raw_timeincrement, &tmp_timeincrement, sizeof(tmp_timeincrement));
  if (raw_timeincrement != 0) {
    total_size += 1 + 4;
  }

  // float scanTime = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scantime = this->_internal_scantime();
  uint32_t raw_scantime;
  memcpy(&raw_scantime, &tmp_scantime, sizeof(tmp_scantime));
  if (raw_scantime != 0) {
    total_size += 1 + 4;
  }

  // float rangeMin = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rangemin = this->_internal_rangemin();
  uint32_t raw_rangemin;
  memcpy(&raw_rangemin, &tmp_rangemin, sizeof(tmp_rangemin));
  if (raw_rangemin != 0) {
    total_size += 1 + 4;
  }

  // float rangeMax = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rangemax = this->_internal_rangemax();
  uint32_t raw_rangemax;
  memcpy(&raw_rangemax, &tmp_rangemax, sizeof(tmp_rangemax));
  if (raw_rangemax != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LaserScan::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LaserScan::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LaserScan::GetClassData() const { return &_class_data_; }


void LaserScan::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LaserScan*>(&to_msg);
  auto& from = static_cast<const LaserScan&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensor_msgs.LaserScan)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ranges_.MergeFrom(from._impl_.ranges_);
  _this->_impl_.intensities_.MergeFrom(from._impl_.intensities_);
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::std_msgs::Header::MergeFrom(
        from._internal_header());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_anglemin = from._internal_anglemin();
  uint32_t raw_anglemin;
  memcpy(&raw_anglemin, &tmp_anglemin, sizeof(tmp_anglemin));
  if (raw_anglemin != 0) {
    _this->_internal_set_anglemin(from._internal_anglemin());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_anglemax = from._internal_anglemax();
  uint32_t raw_anglemax;
  memcpy(&raw_anglemax, &tmp_anglemax, sizeof(tmp_anglemax));
  if (raw_anglemax != 0) {
    _this->_internal_set_anglemax(from._internal_anglemax());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_angleincrement = from._internal_angleincrement();
  uint32_t raw_angleincrement;
  memcpy(&raw_angleincrement, &tmp_angleincrement, sizeof(tmp_angleincrement));
  if (raw_angleincrement != 0) {
    _this->_internal_set_angleincrement(from._internal_angleincrement());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_timeincrement = from._internal_timeincrement();
  uint32_t raw_timeincrement;
  memcpy(&raw_timeincrement, &tmp_timeincrement, sizeof(tmp_timeincrement));
  if (raw_timeincrement != 0) {
    _this->_internal_set_timeincrement(from._internal_timeincrement());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scantime = from._internal_scantime();
  uint32_t raw_scantime;
  memcpy(&raw_scantime, &tmp_scantime, sizeof(tmp_scantime));
  if (raw_scantime != 0) {
    _this->_internal_set_scantime(from._internal_scantime());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rangemin = from._internal_rangemin();
  uint32_t raw_rangemin;
  memcpy(&raw_rangemin, &tmp_rangemin, sizeof(tmp_rangemin));
  if (raw_rangemin != 0) {
    _this->_internal_set_rangemin(from._internal_rangemin());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rangemax = from._internal_rangemax();
  uint32_t raw_rangemax;
  memcpy(&raw_rangemax, &tmp_rangemax, sizeof(tmp_rangemax));
  if (raw_rangemax != 0) {
    _this->_internal_set_rangemax(from._internal_rangemax());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LaserScan::CopyFrom(const LaserScan& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensor_msgs.LaserScan)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaserScan::IsInitialized() const {
  return true;
}

void LaserScan::InternalSwap(LaserScan* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.ranges_.InternalSwap(&other->_impl_.ranges_);
  _impl_.intensities_.InternalSwap(&other->_impl_.intensities_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LaserScan, _impl_.rangemax_)
      + sizeof(LaserScan::_impl_.rangemax_)
      - PROTOBUF_FIELD_OFFSET(LaserScan, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LaserScan::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensor_5fmsgs_2eproto_getter, &descriptor_table_sensor_5fmsgs_2eproto_once,
      file_level_metadata_sensor_5fmsgs_2eproto[4]);
}

// ===================================================================

class Imu::_Internal {
 public:
  static const ::std_msgs::Header& header(const Imu* msg);
  static const ::std_msgs::Vector3f& angularvelocity(const Imu* msg);
  static const ::std_msgs::Vector3f& linearacceleration(const Imu* msg);
  static const ::std_msgs::Vector3f& magnetometerdata(const Imu* msg);
  static const ::std_msgs::Vector3f& euler(const Imu* msg);
  static const ::std_msgs::Quaternionf& orientation(const Imu* msg);
};

const ::std_msgs::Header&
Imu::_Internal::header(const Imu* msg) {
  return *msg->_impl_.header_;
}
const ::std_msgs::Vector3f&
Imu::_Internal::angularvelocity(const Imu* msg) {
  return *msg->_impl_.angularvelocity_;
}
const ::std_msgs::Vector3f&
Imu::_Internal::linearacceleration(const Imu* msg) {
  return *msg->_impl_.linearacceleration_;
}
const ::std_msgs::Vector3f&
Imu::_Internal::magnetometerdata(const Imu* msg) {
  return *msg->_impl_.magnetometerdata_;
}
const ::std_msgs::Vector3f&
Imu::_Internal::euler(const Imu* msg) {
  return *msg->_impl_.euler_;
}
const ::std_msgs::Quaternionf&
Imu::_Internal::orientation(const Imu* msg) {
  return *msg->_impl_.orientation_;
}
void Imu::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
void Imu::clear_angularvelocity() {
  if (GetArenaForAllocation() == nullptr && _impl_.angularvelocity_ != nullptr) {
    delete _impl_.angularvelocity_;
  }
  _impl_.angularvelocity_ = nullptr;
}
void Imu::clear_linearacceleration() {
  if (GetArenaForAllocation() == nullptr && _impl_.linearacceleration_ != nullptr) {
    delete _impl_.linearacceleration_;
  }
  _impl_.linearacceleration_ = nullptr;
}
void Imu::clear_magnetometerdata() {
  if (GetArenaForAllocation() == nullptr && _impl_.magnetometerdata_ != nullptr) {
    delete _impl_.magnetometerdata_;
  }
  _impl_.magnetometerdata_ = nullptr;
}
void Imu::clear_euler() {
  if (GetArenaForAllocation() == nullptr && _impl_.euler_ != nullptr) {
    delete _impl_.euler_;
  }
  _impl_.euler_ = nullptr;
}
void Imu::clear_orientation() {
  if (GetArenaForAllocation() == nullptr && _impl_.orientation_ != nullptr) {
    delete _impl_.orientation_;
  }
  _impl_.orientation_ = nullptr;
}
Imu::Imu(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:sensor_msgs.Imu)
}
Imu::Imu(const Imu& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Imu* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.angularvelocity_){nullptr}
    , decltype(_impl_.linearacceleration_){nullptr}
    , decltype(_impl_.magnetometerdata_){nullptr}
    , decltype(_impl_.euler_){nullptr}
    , decltype(_impl_.orientation_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::std_msgs::Header(*from._impl_.header_);
  }
  if (from._internal_has_angularvelocity()) {
    _this->_impl_.angularvelocity_ = new ::std_msgs::Vector3f(*from._impl_.angularvelocity_);
  }
  if (from._internal_has_linearacceleration()) {
    _this->_impl_.linearacceleration_ = new ::std_msgs::Vector3f(*from._impl_.linearacceleration_);
  }
  if (from._internal_has_magnetometerdata()) {
    _this->_impl_.magnetometerdata_ = new ::std_msgs::Vector3f(*from._impl_.magnetometerdata_);
  }
  if (from._internal_has_euler()) {
    _this->_impl_.euler_ = new ::std_msgs::Vector3f(*from._impl_.euler_);
  }
  if (from._internal_has_orientation()) {
    _this->_impl_.orientation_ = new ::std_msgs::Quaternionf(*from._impl_.orientation_);
  }
  // @@protoc_insertion_point(copy_constructor:sensor_msgs.Imu)
}

inline void Imu::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.angularvelocity_){nullptr}
    , decltype(_impl_.linearacceleration_){nullptr}
    , decltype(_impl_.magnetometerdata_){nullptr}
    , decltype(_impl_.euler_){nullptr}
    , decltype(_impl_.orientation_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Imu::~Imu() {
  // @@protoc_insertion_point(destructor:sensor_msgs.Imu)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Imu::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.angularvelocity_;
  if (this != internal_default_instance()) delete _impl_.linearacceleration_;
  if (this != internal_default_instance()) delete _impl_.magnetometerdata_;
  if (this != internal_default_instance()) delete _impl_.euler_;
  if (this != internal_default_instance()) delete _impl_.orientation_;
}

void Imu::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Imu::Clear() {
// @@protoc_insertion_point(message_clear_start:sensor_msgs.Imu)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.angularvelocity_ != nullptr) {
    delete _impl_.angularvelocity_;
  }
  _impl_.angularvelocity_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.linearacceleration_ != nullptr) {
    delete _impl_.linearacceleration_;
  }
  _impl_.linearacceleration_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.magnetometerdata_ != nullptr) {
    delete _impl_.magnetometerdata_;
  }
  _impl_.magnetometerdata_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.euler_ != nullptr) {
    delete _impl_.euler_;
  }
  _impl_.euler_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.orientation_ != nullptr) {
    delete _impl_.orientation_;
  }
  _impl_.orientation_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Imu::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .std_msgs.Header header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .std_msgs.Vector3f angularVelocity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_angularvelocity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .std_msgs.Vector3f linearAcceleration = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_linearacceleration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .std_msgs.Vector3f magnetometerData = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_magnetometerdata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .std_msgs.Vector3f euler = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_euler(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .std_msgs.Quaternionf orientation = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_orientation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Imu::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensor_msgs.Imu)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .std_msgs.Header header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // .std_msgs.Vector3f angularVelocity = 2;
  if (this->_internal_has_angularvelocity()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::angularvelocity(this),
        _Internal::angularvelocity(this).GetCachedSize(), target, stream);
  }

  // .std_msgs.Vector3f linearAcceleration = 3;
  if (this->_internal_has_linearacceleration()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::linearacceleration(this),
        _Internal::linearacceleration(this).GetCachedSize(), target, stream);
  }

  // .std_msgs.Vector3f magnetometerData = 4;
  if (this->_internal_has_magnetometerdata()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::magnetometerdata(this),
        _Internal::magnetometerdata(this).GetCachedSize(), target, stream);
  }

  // .std_msgs.Vector3f euler = 5;
  if (this->_internal_has_euler()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::euler(this),
        _Internal::euler(this).GetCachedSize(), target, stream);
  }

  // .std_msgs.Quaternionf orientation = 6;
  if (this->_internal_has_orientation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::orientation(this),
        _Internal::orientation(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensor_msgs.Imu)
  return target;
}

size_t Imu::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensor_msgs.Imu)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .std_msgs.Header header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // .std_msgs.Vector3f angularVelocity = 2;
  if (this->_internal_has_angularvelocity()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.angularvelocity_);
  }

  // .std_msgs.Vector3f linearAcceleration = 3;
  if (this->_internal_has_linearacceleration()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.linearacceleration_);
  }

  // .std_msgs.Vector3f magnetometerData = 4;
  if (this->_internal_has_magnetometerdata()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.magnetometerdata_);
  }

  // .std_msgs.Vector3f euler = 5;
  if (this->_internal_has_euler()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.euler_);
  }

  // .std_msgs.Quaternionf orientation = 6;
  if (this->_internal_has_orientation()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.orientation_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Imu::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Imu::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Imu::GetClassData() const { return &_class_data_; }


void Imu::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Imu*>(&to_msg);
  auto& from = static_cast<const Imu&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensor_msgs.Imu)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::std_msgs::Header::MergeFrom(
        from._internal_header());
  }
  if (from._internal_has_angularvelocity()) {
    _this->_internal_mutable_angularvelocity()->::std_msgs::Vector3f::MergeFrom(
        from._internal_angularvelocity());
  }
  if (from._internal_has_linearacceleration()) {
    _this->_internal_mutable_linearacceleration()->::std_msgs::Vector3f::MergeFrom(
        from._internal_linearacceleration());
  }
  if (from._internal_has_magnetometerdata()) {
    _this->_internal_mutable_magnetometerdata()->::std_msgs::Vector3f::MergeFrom(
        from._internal_magnetometerdata());
  }
  if (from._internal_has_euler()) {
    _this->_internal_mutable_euler()->::std_msgs::Vector3f::MergeFrom(
        from._internal_euler());
  }
  if (from._internal_has_orientation()) {
    _this->_internal_mutable_orientation()->::std_msgs::Quaternionf::MergeFrom(
        from._internal_orientation());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Imu::CopyFrom(const Imu& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensor_msgs.Imu)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Imu::IsInitialized() const {
  return true;
}

void Imu::InternalSwap(Imu* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Imu, _impl_.orientation_)
      + sizeof(Imu::_impl_.orientation_)
      - PROTOBUF_FIELD_OFFSET(Imu, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Imu::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensor_5fmsgs_2eproto_getter, &descriptor_table_sensor_5fmsgs_2eproto_once,
      file_level_metadata_sensor_5fmsgs_2eproto[5]);
}

// ===================================================================

class Odometry::_Internal {
 public:
  static const ::std_msgs::Header& header(const Odometry* msg);
  static const ::std_msgs::Vector3f& position(const Odometry* msg);
  static const ::std_msgs::Vector3f& angular(const Odometry* msg);
  static const ::std_msgs::Vector3f& linearacceleration(const Odometry* msg);
  static const ::std_msgs::Vector3f& angularvelocity(const Odometry* msg);
};

const ::std_msgs::Header&
Odometry::_Internal::header(const Odometry* msg) {
  return *msg->_impl_.header_;
}
const ::std_msgs::Vector3f&
Odometry::_Internal::position(const Odometry* msg) {
  return *msg->_impl_.position_;
}
const ::std_msgs::Vector3f&
Odometry::_Internal::angular(const Odometry* msg) {
  return *msg->_impl_.angular_;
}
const ::std_msgs::Vector3f&
Odometry::_Internal::linearacceleration(const Odometry* msg) {
  return *msg->_impl_.linearacceleration_;
}
const ::std_msgs::Vector3f&
Odometry::_Internal::angularvelocity(const Odometry* msg) {
  return *msg->_impl_.angularvelocity_;
}
void Odometry::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
void Odometry::clear_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
}
void Odometry::clear_angular() {
  if (GetArenaForAllocation() == nullptr && _impl_.angular_ != nullptr) {
    delete _impl_.angular_;
  }
  _impl_.angular_ = nullptr;
}
void Odometry::clear_linearacceleration() {
  if (GetArenaForAllocation() == nullptr && _impl_.linearacceleration_ != nullptr) {
    delete _impl_.linearacceleration_;
  }
  _impl_.linearacceleration_ = nullptr;
}
void Odometry::clear_angularvelocity() {
  if (GetArenaForAllocation() == nullptr && _impl_.angularvelocity_ != nullptr) {
    delete _impl_.angularvelocity_;
  }
  _impl_.angularvelocity_ = nullptr;
}
Odometry::Odometry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:sensor_msgs.Odometry)
}
Odometry::Odometry(const Odometry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Odometry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.childframeid_){}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.angular_){nullptr}
    , decltype(_impl_.linearacceleration_){nullptr}
    , decltype(_impl_.angularvelocity_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.childframeid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.childframeid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_childframeid().empty()) {
    _this->_impl_.childframeid_.Set(from._internal_childframeid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::std_msgs::Header(*from._impl_.header_);
  }
  if (from._internal_has_position()) {
    _this->_impl_.position_ = new ::std_msgs::Vector3f(*from._impl_.position_);
  }
  if (from._internal_has_angular()) {
    _this->_impl_.angular_ = new ::std_msgs::Vector3f(*from._impl_.angular_);
  }
  if (from._internal_has_linearacceleration()) {
    _this->_impl_.linearacceleration_ = new ::std_msgs::Vector3f(*from._impl_.linearacceleration_);
  }
  if (from._internal_has_angularvelocity()) {
    _this->_impl_.angularvelocity_ = new ::std_msgs::Vector3f(*from._impl_.angularvelocity_);
  }
  // @@protoc_insertion_point(copy_constructor:sensor_msgs.Odometry)
}

inline void Odometry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.childframeid_){}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.angular_){nullptr}
    , decltype(_impl_.linearacceleration_){nullptr}
    , decltype(_impl_.angularvelocity_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.childframeid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.childframeid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Odometry::~Odometry() {
  // @@protoc_insertion_point(destructor:sensor_msgs.Odometry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Odometry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.childframeid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.angular_;
  if (this != internal_default_instance()) delete _impl_.linearacceleration_;
  if (this != internal_default_instance()) delete _impl_.angularvelocity_;
}

void Odometry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Odometry::Clear() {
// @@protoc_insertion_point(message_clear_start:sensor_msgs.Odometry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.childframeid_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.angular_ != nullptr) {
    delete _impl_.angular_;
  }
  _impl_.angular_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.linearacceleration_ != nullptr) {
    delete _impl_.linearacceleration_;
  }
  _impl_.linearacceleration_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.angularvelocity_ != nullptr) {
    delete _impl_.angularvelocity_;
  }
  _impl_.angularvelocity_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Odometry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .std_msgs.Header header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string childFrameId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_childframeid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "sensor_msgs.Odometry.childFrameId"));
        } else
          goto handle_unusual;
        continue;
      // .std_msgs.Vector3f position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .std_msgs.Vector3f angular = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_angular(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .std_msgs.Vector3f linearAcceleration = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_linearacceleration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .std_msgs.Vector3f angularVelocity = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_angularvelocity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Odometry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensor_msgs.Odometry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .std_msgs.Header header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // string childFrameId = 2;
  if (!this->_internal_childframeid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_childframeid().data(), static_cast<int>(this->_internal_childframeid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "sensor_msgs.Odometry.childFrameId");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_childframeid(), target);
  }

  // .std_msgs.Vector3f position = 3;
  if (this->_internal_has_position()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // .std_msgs.Vector3f angular = 4;
  if (this->_internal_has_angular()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::angular(this),
        _Internal::angular(this).GetCachedSize(), target, stream);
  }

  // .std_msgs.Vector3f linearAcceleration = 5;
  if (this->_internal_has_linearacceleration()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::linearacceleration(this),
        _Internal::linearacceleration(this).GetCachedSize(), target, stream);
  }

  // .std_msgs.Vector3f angularVelocity = 6;
  if (this->_internal_has_angularvelocity()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::angularvelocity(this),
        _Internal::angularvelocity(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensor_msgs.Odometry)
  return target;
}

size_t Odometry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensor_msgs.Odometry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string childFrameId = 2;
  if (!this->_internal_childframeid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_childframeid());
  }

  // .std_msgs.Header header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // .std_msgs.Vector3f position = 3;
  if (this->_internal_has_position()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  // .std_msgs.Vector3f angular = 4;
  if (this->_internal_has_angular()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.angular_);
  }

  // .std_msgs.Vector3f linearAcceleration = 5;
  if (this->_internal_has_linearacceleration()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.linearacceleration_);
  }

  // .std_msgs.Vector3f angularVelocity = 6;
  if (this->_internal_has_angularvelocity()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.angularvelocity_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Odometry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Odometry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Odometry::GetClassData() const { return &_class_data_; }


void Odometry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Odometry*>(&to_msg);
  auto& from = static_cast<const Odometry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensor_msgs.Odometry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_childframeid().empty()) {
    _this->_internal_set_childframeid(from._internal_childframeid());
  }
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::std_msgs::Header::MergeFrom(
        from._internal_header());
  }
  if (from._internal_has_position()) {
    _this->_internal_mutable_position()->::std_msgs::Vector3f::MergeFrom(
        from._internal_position());
  }
  if (from._internal_has_angular()) {
    _this->_internal_mutable_angular()->::std_msgs::Vector3f::MergeFrom(
        from._internal_angular());
  }
  if (from._internal_has_linearacceleration()) {
    _this->_internal_mutable_linearacceleration()->::std_msgs::Vector3f::MergeFrom(
        from._internal_linearacceleration());
  }
  if (from._internal_has_angularvelocity()) {
    _this->_internal_mutable_angularvelocity()->::std_msgs::Vector3f::MergeFrom(
        from._internal_angularvelocity());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Odometry::CopyFrom(const Odometry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensor_msgs.Odometry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Odometry::IsInitialized() const {
  return true;
}

void Odometry::InternalSwap(Odometry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.childframeid_, lhs_arena,
      &other->_impl_.childframeid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Odometry, _impl_.angularvelocity_)
      + sizeof(Odometry::_impl_.angularvelocity_)
      - PROTOBUF_FIELD_OFFSET(Odometry, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Odometry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensor_5fmsgs_2eproto_getter, &descriptor_table_sensor_5fmsgs_2eproto_once,
      file_level_metadata_sensor_5fmsgs_2eproto[6]);
}

// ===================================================================

class OccupancyMap::_Internal {
 public:
  static const ::std_msgs::Header& header(const OccupancyMap* msg);
};

const ::std_msgs::Header&
OccupancyMap::_Internal::header(const OccupancyMap* msg) {
  return *msg->_impl_.header_;
}
void OccupancyMap::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
OccupancyMap::OccupancyMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:sensor_msgs.OccupancyMap)
}
OccupancyMap::OccupancyMap(const OccupancyMap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OccupancyMap* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){from._impl_.data_}
    , /*decltype(_impl_._data_cached_byte_size_)*/{0}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.resolution_){}
    , decltype(_impl_.width_){}
    , decltype(_impl_.height_){}
    , decltype(_impl_.origin_x_){}
    , decltype(_impl_.origin_y_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::std_msgs::Header(*from._impl_.header_);
  }
  ::memcpy(&_impl_.resolution_, &from._impl_.resolution_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.origin_y_) -
    reinterpret_cast<char*>(&_impl_.resolution_)) + sizeof(_impl_.origin_y_));
  // @@protoc_insertion_point(copy_constructor:sensor_msgs.OccupancyMap)
}

inline void OccupancyMap::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){arena}
    , /*decltype(_impl_._data_cached_byte_size_)*/{0}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.resolution_){0}
    , decltype(_impl_.width_){0}
    , decltype(_impl_.height_){0}
    , decltype(_impl_.origin_x_){0}
    , decltype(_impl_.origin_y_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OccupancyMap::~OccupancyMap() {
  // @@protoc_insertion_point(destructor:sensor_msgs.OccupancyMap)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OccupancyMap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void OccupancyMap::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OccupancyMap::Clear() {
// @@protoc_insertion_point(message_clear_start:sensor_msgs.OccupancyMap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  ::memset(&_impl_.resolution_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.origin_y_) -
      reinterpret_cast<char*>(&_impl_.resolution_)) + sizeof(_impl_.origin_y_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OccupancyMap::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .std_msgs.Header header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float resolution = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.resolution_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // int32 width = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 height = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float origin_x = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _impl_.origin_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float origin_y = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _impl_.origin_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 data = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_data(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 56) {
          _internal_add_data(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OccupancyMap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensor_msgs.OccupancyMap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .std_msgs.Header header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // float resolution = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_resolution = this->_internal_resolution();
  uint32_t raw_resolution;
  memcpy(&raw_resolution, &tmp_resolution, sizeof(tmp_resolution));
  if (raw_resolution != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_resolution(), target);
  }

  // int32 width = 3;
  if (this->_internal_width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_width(), target);
  }

  // int32 height = 4;
  if (this->_internal_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_height(), target);
  }

  // float origin_x = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_origin_x = this->_internal_origin_x();
  uint32_t raw_origin_x;
  memcpy(&raw_origin_x, &tmp_origin_x, sizeof(tmp_origin_x));
  if (raw_origin_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_origin_x(), target);
  }

  // float origin_y = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_origin_y = this->_internal_origin_y();
  uint32_t raw_origin_y;
  memcpy(&raw_origin_y, &tmp_origin_y, sizeof(tmp_origin_y));
  if (raw_origin_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_origin_y(), target);
  }

  // repeated int32 data = 7;
  {
    int byte_size = _impl_._data_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          7, _internal_data(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensor_msgs.OccupancyMap)
  return target;
}

size_t OccupancyMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensor_msgs.OccupancyMap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 data = 7;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.data_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._data_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // .std_msgs.Header header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // float resolution = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_resolution = this->_internal_resolution();
  uint32_t raw_resolution;
  memcpy(&raw_resolution, &tmp_resolution, sizeof(tmp_resolution));
  if (raw_resolution != 0) {
    total_size += 1 + 4;
  }

  // int32 width = 3;
  if (this->_internal_width() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_width());
  }

  // int32 height = 4;
  if (this->_internal_height() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_height());
  }

  // float origin_x = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_origin_x = this->_internal_origin_x();
  uint32_t raw_origin_x;
  memcpy(&raw_origin_x, &tmp_origin_x, sizeof(tmp_origin_x));
  if (raw_origin_x != 0) {
    total_size += 1 + 4;
  }

  // float origin_y = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_origin_y = this->_internal_origin_y();
  uint32_t raw_origin_y;
  memcpy(&raw_origin_y, &tmp_origin_y, sizeof(tmp_origin_y));
  if (raw_origin_y != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OccupancyMap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OccupancyMap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OccupancyMap::GetClassData() const { return &_class_data_; }


void OccupancyMap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OccupancyMap*>(&to_msg);
  auto& from = static_cast<const OccupancyMap&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensor_msgs.OccupancyMap)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.data_.MergeFrom(from._impl_.data_);
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::std_msgs::Header::MergeFrom(
        from._internal_header());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_resolution = from._internal_resolution();
  uint32_t raw_resolution;
  memcpy(&raw_resolution, &tmp_resolution, sizeof(tmp_resolution));
  if (raw_resolution != 0) {
    _this->_internal_set_resolution(from._internal_resolution());
  }
  if (from._internal_width() != 0) {
    _this->_internal_set_width(from._internal_width());
  }
  if (from._internal_height() != 0) {
    _this->_internal_set_height(from._internal_height());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_origin_x = from._internal_origin_x();
  uint32_t raw_origin_x;
  memcpy(&raw_origin_x, &tmp_origin_x, sizeof(tmp_origin_x));
  if (raw_origin_x != 0) {
    _this->_internal_set_origin_x(from._internal_origin_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_origin_y = from._internal_origin_y();
  uint32_t raw_origin_y;
  memcpy(&raw_origin_y, &tmp_origin_y, sizeof(tmp_origin_y));
  if (raw_origin_y != 0) {
    _this->_internal_set_origin_y(from._internal_origin_y());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OccupancyMap::CopyFrom(const OccupancyMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensor_msgs.OccupancyMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OccupancyMap::IsInitialized() const {
  return true;
}

void OccupancyMap::InternalSwap(OccupancyMap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.data_.InternalSwap(&other->_impl_.data_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OccupancyMap, _impl_.origin_y_)
      + sizeof(OccupancyMap::_impl_.origin_y_)
      - PROTOBUF_FIELD_OFFSET(OccupancyMap, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OccupancyMap::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensor_5fmsgs_2eproto_getter, &descriptor_table_sensor_5fmsgs_2eproto_once,
      file_level_metadata_sensor_5fmsgs_2eproto[7]);
}

// ===================================================================

class ESDFMap::_Internal {
 public:
  static const ::std_msgs::Header& header(const ESDFMap* msg);
};

const ::std_msgs::Header&
ESDFMap::_Internal::header(const ESDFMap* msg) {
  return *msg->_impl_.header_;
}
void ESDFMap::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
void ESDFMap::clear_points() {
  _impl_.points_.Clear();
}
ESDFMap::ESDFMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:sensor_msgs.ESDFMap)
}
ESDFMap::ESDFMap(const ESDFMap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ESDFMap* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.points_){from._impl_.points_}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::std_msgs::Header(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:sensor_msgs.ESDFMap)
}

inline void ESDFMap::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.points_){arena}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ESDFMap::~ESDFMap() {
  // @@protoc_insertion_point(destructor:sensor_msgs.ESDFMap)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ESDFMap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.points_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void ESDFMap::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ESDFMap::Clear() {
// @@protoc_insertion_point(message_clear_start:sensor_msgs.ESDFMap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.points_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ESDFMap::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .std_msgs.Header header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .std_msgs.Vector4f points = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_points(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ESDFMap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensor_msgs.ESDFMap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .std_msgs.Header header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // repeated .std_msgs.Vector4f points = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_points_size()); i < n; i++) {
    const auto& repfield = this->_internal_points(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensor_msgs.ESDFMap)
  return target;
}

size_t ESDFMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensor_msgs.ESDFMap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .std_msgs.Vector4f points = 2;
  total_size += 1UL * this->_internal_points_size();
  for (const auto& msg : this->_impl_.points_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .std_msgs.Header header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ESDFMap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ESDFMap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ESDFMap::GetClassData() const { return &_class_data_; }


void ESDFMap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ESDFMap*>(&to_msg);
  auto& from = static_cast<const ESDFMap&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensor_msgs.ESDFMap)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.points_.MergeFrom(from._impl_.points_);
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::std_msgs::Header::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ESDFMap::CopyFrom(const ESDFMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensor_msgs.ESDFMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ESDFMap::IsInitialized() const {
  return true;
}

void ESDFMap::InternalSwap(ESDFMap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.points_.InternalSwap(&other->_impl_.points_);
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ESDFMap::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensor_5fmsgs_2eproto_getter, &descriptor_table_sensor_5fmsgs_2eproto_once,
      file_level_metadata_sensor_5fmsgs_2eproto[8]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace sensor_msgs
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::sensor_msgs::Twist2D*
Arena::CreateMaybeMessage< ::sensor_msgs::Twist2D >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sensor_msgs::Twist2D >(arena);
}
template<> PROTOBUF_NOINLINE ::sensor_msgs::Twist2DStamp*
Arena::CreateMaybeMessage< ::sensor_msgs::Twist2DStamp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sensor_msgs::Twist2DStamp >(arena);
}
template<> PROTOBUF_NOINLINE ::sensor_msgs::PointCloud2f*
Arena::CreateMaybeMessage< ::sensor_msgs::PointCloud2f >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sensor_msgs::PointCloud2f >(arena);
}
template<> PROTOBUF_NOINLINE ::sensor_msgs::PointCloud3f*
Arena::CreateMaybeMessage< ::sensor_msgs::PointCloud3f >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sensor_msgs::PointCloud3f >(arena);
}
template<> PROTOBUF_NOINLINE ::sensor_msgs::LaserScan*
Arena::CreateMaybeMessage< ::sensor_msgs::LaserScan >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sensor_msgs::LaserScan >(arena);
}
template<> PROTOBUF_NOINLINE ::sensor_msgs::Imu*
Arena::CreateMaybeMessage< ::sensor_msgs::Imu >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sensor_msgs::Imu >(arena);
}
template<> PROTOBUF_NOINLINE ::sensor_msgs::Odometry*
Arena::CreateMaybeMessage< ::sensor_msgs::Odometry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sensor_msgs::Odometry >(arena);
}
template<> PROTOBUF_NOINLINE ::sensor_msgs::OccupancyMap*
Arena::CreateMaybeMessage< ::sensor_msgs::OccupancyMap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sensor_msgs::OccupancyMap >(arena);
}
template<> PROTOBUF_NOINLINE ::sensor_msgs::ESDFMap*
Arena::CreateMaybeMessage< ::sensor_msgs::ESDFMap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sensor_msgs::ESDFMap >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
