// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensor_msgs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sensor_5fmsgs_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sensor_5fmsgs_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "std_msgs.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sensor_5fmsgs_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sensor_5fmsgs_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sensor_5fmsgs_2eproto;
namespace sensor_msgs {
class ESDFMap;
struct ESDFMapDefaultTypeInternal;
extern ESDFMapDefaultTypeInternal _ESDFMap_default_instance_;
class Imu;
struct ImuDefaultTypeInternal;
extern ImuDefaultTypeInternal _Imu_default_instance_;
class LaserScan;
struct LaserScanDefaultTypeInternal;
extern LaserScanDefaultTypeInternal _LaserScan_default_instance_;
class OccupancyMap;
struct OccupancyMapDefaultTypeInternal;
extern OccupancyMapDefaultTypeInternal _OccupancyMap_default_instance_;
class Odometry;
struct OdometryDefaultTypeInternal;
extern OdometryDefaultTypeInternal _Odometry_default_instance_;
class PointCloud2f;
struct PointCloud2fDefaultTypeInternal;
extern PointCloud2fDefaultTypeInternal _PointCloud2f_default_instance_;
class PointCloud3f;
struct PointCloud3fDefaultTypeInternal;
extern PointCloud3fDefaultTypeInternal _PointCloud3f_default_instance_;
class Twist2D;
struct Twist2DDefaultTypeInternal;
extern Twist2DDefaultTypeInternal _Twist2D_default_instance_;
class Twist2DStamp;
struct Twist2DStampDefaultTypeInternal;
extern Twist2DStampDefaultTypeInternal _Twist2DStamp_default_instance_;
}  // namespace sensor_msgs
PROTOBUF_NAMESPACE_OPEN
template<> ::sensor_msgs::ESDFMap* Arena::CreateMaybeMessage<::sensor_msgs::ESDFMap>(Arena*);
template<> ::sensor_msgs::Imu* Arena::CreateMaybeMessage<::sensor_msgs::Imu>(Arena*);
template<> ::sensor_msgs::LaserScan* Arena::CreateMaybeMessage<::sensor_msgs::LaserScan>(Arena*);
template<> ::sensor_msgs::OccupancyMap* Arena::CreateMaybeMessage<::sensor_msgs::OccupancyMap>(Arena*);
template<> ::sensor_msgs::Odometry* Arena::CreateMaybeMessage<::sensor_msgs::Odometry>(Arena*);
template<> ::sensor_msgs::PointCloud2f* Arena::CreateMaybeMessage<::sensor_msgs::PointCloud2f>(Arena*);
template<> ::sensor_msgs::PointCloud3f* Arena::CreateMaybeMessage<::sensor_msgs::PointCloud3f>(Arena*);
template<> ::sensor_msgs::Twist2D* Arena::CreateMaybeMessage<::sensor_msgs::Twist2D>(Arena*);
template<> ::sensor_msgs::Twist2DStamp* Arena::CreateMaybeMessage<::sensor_msgs::Twist2DStamp>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sensor_msgs {

// ===================================================================

class Twist2D final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensor_msgs.Twist2D) */ {
 public:
  inline Twist2D() : Twist2D(nullptr) {}
  ~Twist2D() override;
  explicit PROTOBUF_CONSTEXPR Twist2D(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Twist2D(const Twist2D& from);
  Twist2D(Twist2D&& from) noexcept
    : Twist2D() {
    *this = ::std::move(from);
  }

  inline Twist2D& operator=(const Twist2D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Twist2D& operator=(Twist2D&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Twist2D& default_instance() {
    return *internal_default_instance();
  }
  static inline const Twist2D* internal_default_instance() {
    return reinterpret_cast<const Twist2D*>(
               &_Twist2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Twist2D& a, Twist2D& b) {
    a.Swap(&b);
  }
  inline void Swap(Twist2D* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Twist2D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Twist2D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Twist2D>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Twist2D& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Twist2D& from) {
    Twist2D::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Twist2D* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensor_msgs.Twist2D";
  }
  protected:
  explicit Twist2D(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVXFieldNumber = 1,
    kVYFieldNumber = 2,
    kOmegaFieldNumber = 3,
  };
  // float v_x = 1;
  void clear_v_x();
  float v_x() const;
  void set_v_x(float value);
  private:
  float _internal_v_x() const;
  void _internal_set_v_x(float value);
  public:

  // float v_y = 2;
  void clear_v_y();
  float v_y() const;
  void set_v_y(float value);
  private:
  float _internal_v_y() const;
  void _internal_set_v_y(float value);
  public:

  // float omega = 3;
  void clear_omega();
  float omega() const;
  void set_omega(float value);
  private:
  float _internal_omega() const;
  void _internal_set_omega(float value);
  public:

  // @@protoc_insertion_point(class_scope:sensor_msgs.Twist2D)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float v_x_;
    float v_y_;
    float omega_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensor_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class Twist2DStamp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensor_msgs.Twist2DStamp) */ {
 public:
  inline Twist2DStamp() : Twist2DStamp(nullptr) {}
  ~Twist2DStamp() override;
  explicit PROTOBUF_CONSTEXPR Twist2DStamp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Twist2DStamp(const Twist2DStamp& from);
  Twist2DStamp(Twist2DStamp&& from) noexcept
    : Twist2DStamp() {
    *this = ::std::move(from);
  }

  inline Twist2DStamp& operator=(const Twist2DStamp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Twist2DStamp& operator=(Twist2DStamp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Twist2DStamp& default_instance() {
    return *internal_default_instance();
  }
  static inline const Twist2DStamp* internal_default_instance() {
    return reinterpret_cast<const Twist2DStamp*>(
               &_Twist2DStamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Twist2DStamp& a, Twist2DStamp& b) {
    a.Swap(&b);
  }
  inline void Swap(Twist2DStamp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Twist2DStamp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Twist2DStamp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Twist2DStamp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Twist2DStamp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Twist2DStamp& from) {
    Twist2DStamp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Twist2DStamp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensor_msgs.Twist2DStamp";
  }
  protected:
  explicit Twist2DStamp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kTwistFieldNumber = 2,
  };
  // .std_msgs.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::std_msgs::Header& header() const;
  PROTOBUF_NODISCARD ::std_msgs::Header* release_header();
  ::std_msgs::Header* mutable_header();
  void set_allocated_header(::std_msgs::Header* header);
  private:
  const ::std_msgs::Header& _internal_header() const;
  ::std_msgs::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::std_msgs::Header* header);
  ::std_msgs::Header* unsafe_arena_release_header();

  // .sensor_msgs.Twist2D twist = 2;
  bool has_twist() const;
  private:
  bool _internal_has_twist() const;
  public:
  void clear_twist();
  const ::sensor_msgs::Twist2D& twist() const;
  PROTOBUF_NODISCARD ::sensor_msgs::Twist2D* release_twist();
  ::sensor_msgs::Twist2D* mutable_twist();
  void set_allocated_twist(::sensor_msgs::Twist2D* twist);
  private:
  const ::sensor_msgs::Twist2D& _internal_twist() const;
  ::sensor_msgs::Twist2D* _internal_mutable_twist();
  public:
  void unsafe_arena_set_allocated_twist(
      ::sensor_msgs::Twist2D* twist);
  ::sensor_msgs::Twist2D* unsafe_arena_release_twist();

  // @@protoc_insertion_point(class_scope:sensor_msgs.Twist2DStamp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::std_msgs::Header* header_;
    ::sensor_msgs::Twist2D* twist_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensor_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class PointCloud2f final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensor_msgs.PointCloud2f) */ {
 public:
  inline PointCloud2f() : PointCloud2f(nullptr) {}
  ~PointCloud2f() override;
  explicit PROTOBUF_CONSTEXPR PointCloud2f(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PointCloud2f(const PointCloud2f& from);
  PointCloud2f(PointCloud2f&& from) noexcept
    : PointCloud2f() {
    *this = ::std::move(from);
  }

  inline PointCloud2f& operator=(const PointCloud2f& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointCloud2f& operator=(PointCloud2f&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointCloud2f& default_instance() {
    return *internal_default_instance();
  }
  static inline const PointCloud2f* internal_default_instance() {
    return reinterpret_cast<const PointCloud2f*>(
               &_PointCloud2f_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PointCloud2f& a, PointCloud2f& b) {
    a.Swap(&b);
  }
  inline void Swap(PointCloud2f* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointCloud2f* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointCloud2f* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PointCloud2f>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PointCloud2f& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PointCloud2f& from) {
    PointCloud2f::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointCloud2f* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensor_msgs.PointCloud2f";
  }
  protected:
  explicit PointCloud2f(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPointsFieldNumber = 2,
  };
  // .std_msgs.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::std_msgs::Header& header() const;
  PROTOBUF_NODISCARD ::std_msgs::Header* release_header();
  ::std_msgs::Header* mutable_header();
  void set_allocated_header(::std_msgs::Header* header);
  private:
  const ::std_msgs::Header& _internal_header() const;
  ::std_msgs::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::std_msgs::Header* header);
  ::std_msgs::Header* unsafe_arena_release_header();

  // .std_msgs.Vector2f points = 2;
  bool has_points() const;
  private:
  bool _internal_has_points() const;
  public:
  void clear_points();
  const ::std_msgs::Vector2f& points() const;
  PROTOBUF_NODISCARD ::std_msgs::Vector2f* release_points();
  ::std_msgs::Vector2f* mutable_points();
  void set_allocated_points(::std_msgs::Vector2f* points);
  private:
  const ::std_msgs::Vector2f& _internal_points() const;
  ::std_msgs::Vector2f* _internal_mutable_points();
  public:
  void unsafe_arena_set_allocated_points(
      ::std_msgs::Vector2f* points);
  ::std_msgs::Vector2f* unsafe_arena_release_points();

  // @@protoc_insertion_point(class_scope:sensor_msgs.PointCloud2f)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::std_msgs::Header* header_;
    ::std_msgs::Vector2f* points_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensor_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class PointCloud3f final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensor_msgs.PointCloud3f) */ {
 public:
  inline PointCloud3f() : PointCloud3f(nullptr) {}
  ~PointCloud3f() override;
  explicit PROTOBUF_CONSTEXPR PointCloud3f(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PointCloud3f(const PointCloud3f& from);
  PointCloud3f(PointCloud3f&& from) noexcept
    : PointCloud3f() {
    *this = ::std::move(from);
  }

  inline PointCloud3f& operator=(const PointCloud3f& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointCloud3f& operator=(PointCloud3f&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointCloud3f& default_instance() {
    return *internal_default_instance();
  }
  static inline const PointCloud3f* internal_default_instance() {
    return reinterpret_cast<const PointCloud3f*>(
               &_PointCloud3f_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PointCloud3f& a, PointCloud3f& b) {
    a.Swap(&b);
  }
  inline void Swap(PointCloud3f* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointCloud3f* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointCloud3f* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PointCloud3f>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PointCloud3f& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PointCloud3f& from) {
    PointCloud3f::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointCloud3f* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensor_msgs.PointCloud3f";
  }
  protected:
  explicit PointCloud3f(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPointsFieldNumber = 2,
  };
  // .std_msgs.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::std_msgs::Header& header() const;
  PROTOBUF_NODISCARD ::std_msgs::Header* release_header();
  ::std_msgs::Header* mutable_header();
  void set_allocated_header(::std_msgs::Header* header);
  private:
  const ::std_msgs::Header& _internal_header() const;
  ::std_msgs::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::std_msgs::Header* header);
  ::std_msgs::Header* unsafe_arena_release_header();

  // .std_msgs.Vector3f points = 2;
  bool has_points() const;
  private:
  bool _internal_has_points() const;
  public:
  void clear_points();
  const ::std_msgs::Vector3f& points() const;
  PROTOBUF_NODISCARD ::std_msgs::Vector3f* release_points();
  ::std_msgs::Vector3f* mutable_points();
  void set_allocated_points(::std_msgs::Vector3f* points);
  private:
  const ::std_msgs::Vector3f& _internal_points() const;
  ::std_msgs::Vector3f* _internal_mutable_points();
  public:
  void unsafe_arena_set_allocated_points(
      ::std_msgs::Vector3f* points);
  ::std_msgs::Vector3f* unsafe_arena_release_points();

  // @@protoc_insertion_point(class_scope:sensor_msgs.PointCloud3f)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::std_msgs::Header* header_;
    ::std_msgs::Vector3f* points_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensor_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class LaserScan final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensor_msgs.LaserScan) */ {
 public:
  inline LaserScan() : LaserScan(nullptr) {}
  ~LaserScan() override;
  explicit PROTOBUF_CONSTEXPR LaserScan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LaserScan(const LaserScan& from);
  LaserScan(LaserScan&& from) noexcept
    : LaserScan() {
    *this = ::std::move(from);
  }

  inline LaserScan& operator=(const LaserScan& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaserScan& operator=(LaserScan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaserScan& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaserScan* internal_default_instance() {
    return reinterpret_cast<const LaserScan*>(
               &_LaserScan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LaserScan& a, LaserScan& b) {
    a.Swap(&b);
  }
  inline void Swap(LaserScan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaserScan* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaserScan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaserScan>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LaserScan& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LaserScan& from) {
    LaserScan::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaserScan* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensor_msgs.LaserScan";
  }
  protected:
  explicit LaserScan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRangesFieldNumber = 9,
    kIntensitiesFieldNumber = 10,
    kHeaderFieldNumber = 1,
    kAngleMinFieldNumber = 2,
    kAngleMaxFieldNumber = 3,
    kAngleIncrementFieldNumber = 4,
    kTimeIncrementFieldNumber = 5,
    kScanTimeFieldNumber = 6,
    kRangeMinFieldNumber = 7,
    kRangeMaxFieldNumber = 8,
  };
  // repeated float ranges = 9;
  int ranges_size() const;
  private:
  int _internal_ranges_size() const;
  public:
  void clear_ranges();
  private:
  float _internal_ranges(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_ranges() const;
  void _internal_add_ranges(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_ranges();
  public:
  float ranges(int index) const;
  void set_ranges(int index, float value);
  void add_ranges(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      ranges() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_ranges();

  // repeated float intensities = 10;
  int intensities_size() const;
  private:
  int _internal_intensities_size() const;
  public:
  void clear_intensities();
  private:
  float _internal_intensities(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_intensities() const;
  void _internal_add_intensities(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_intensities();
  public:
  float intensities(int index) const;
  void set_intensities(int index, float value);
  void add_intensities(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      intensities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_intensities();

  // .std_msgs.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::std_msgs::Header& header() const;
  PROTOBUF_NODISCARD ::std_msgs::Header* release_header();
  ::std_msgs::Header* mutable_header();
  void set_allocated_header(::std_msgs::Header* header);
  private:
  const ::std_msgs::Header& _internal_header() const;
  ::std_msgs::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::std_msgs::Header* header);
  ::std_msgs::Header* unsafe_arena_release_header();

  // float angleMin = 2;
  void clear_anglemin();
  float anglemin() const;
  void set_anglemin(float value);
  private:
  float _internal_anglemin() const;
  void _internal_set_anglemin(float value);
  public:

  // float angleMax = 3;
  void clear_anglemax();
  float anglemax() const;
  void set_anglemax(float value);
  private:
  float _internal_anglemax() const;
  void _internal_set_anglemax(float value);
  public:

  // float angleIncrement = 4;
  void clear_angleincrement();
  float angleincrement() const;
  void set_angleincrement(float value);
  private:
  float _internal_angleincrement() const;
  void _internal_set_angleincrement(float value);
  public:

  // float timeIncrement = 5;
  void clear_timeincrement();
  float timeincrement() const;
  void set_timeincrement(float value);
  private:
  float _internal_timeincrement() const;
  void _internal_set_timeincrement(float value);
  public:

  // float scanTime = 6;
  void clear_scantime();
  float scantime() const;
  void set_scantime(float value);
  private:
  float _internal_scantime() const;
  void _internal_set_scantime(float value);
  public:

  // float rangeMin = 7;
  void clear_rangemin();
  float rangemin() const;
  void set_rangemin(float value);
  private:
  float _internal_rangemin() const;
  void _internal_set_rangemin(float value);
  public:

  // float rangeMax = 8;
  void clear_rangemax();
  float rangemax() const;
  void set_rangemax(float value);
  private:
  float _internal_rangemax() const;
  void _internal_set_rangemax(float value);
  public:

  // @@protoc_insertion_point(class_scope:sensor_msgs.LaserScan)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > ranges_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > intensities_;
    ::std_msgs::Header* header_;
    float anglemin_;
    float anglemax_;
    float angleincrement_;
    float timeincrement_;
    float scantime_;
    float rangemin_;
    float rangemax_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensor_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class Imu final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensor_msgs.Imu) */ {
 public:
  inline Imu() : Imu(nullptr) {}
  ~Imu() override;
  explicit PROTOBUF_CONSTEXPR Imu(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Imu(const Imu& from);
  Imu(Imu&& from) noexcept
    : Imu() {
    *this = ::std::move(from);
  }

  inline Imu& operator=(const Imu& from) {
    CopyFrom(from);
    return *this;
  }
  inline Imu& operator=(Imu&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Imu& default_instance() {
    return *internal_default_instance();
  }
  static inline const Imu* internal_default_instance() {
    return reinterpret_cast<const Imu*>(
               &_Imu_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Imu& a, Imu& b) {
    a.Swap(&b);
  }
  inline void Swap(Imu* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Imu* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Imu* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Imu>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Imu& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Imu& from) {
    Imu::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Imu* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensor_msgs.Imu";
  }
  protected:
  explicit Imu(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kAngularVelocityFieldNumber = 2,
    kLinearAccelerationFieldNumber = 3,
    kMagnetometerDataFieldNumber = 4,
    kEulerFieldNumber = 5,
    kOrientationFieldNumber = 6,
  };
  // .std_msgs.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::std_msgs::Header& header() const;
  PROTOBUF_NODISCARD ::std_msgs::Header* release_header();
  ::std_msgs::Header* mutable_header();
  void set_allocated_header(::std_msgs::Header* header);
  private:
  const ::std_msgs::Header& _internal_header() const;
  ::std_msgs::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::std_msgs::Header* header);
  ::std_msgs::Header* unsafe_arena_release_header();

  // .std_msgs.Vector3f angularVelocity = 2;
  bool has_angularvelocity() const;
  private:
  bool _internal_has_angularvelocity() const;
  public:
  void clear_angularvelocity();
  const ::std_msgs::Vector3f& angularvelocity() const;
  PROTOBUF_NODISCARD ::std_msgs::Vector3f* release_angularvelocity();
  ::std_msgs::Vector3f* mutable_angularvelocity();
  void set_allocated_angularvelocity(::std_msgs::Vector3f* angularvelocity);
  private:
  const ::std_msgs::Vector3f& _internal_angularvelocity() const;
  ::std_msgs::Vector3f* _internal_mutable_angularvelocity();
  public:
  void unsafe_arena_set_allocated_angularvelocity(
      ::std_msgs::Vector3f* angularvelocity);
  ::std_msgs::Vector3f* unsafe_arena_release_angularvelocity();

  // .std_msgs.Vector3f linearAcceleration = 3;
  bool has_linearacceleration() const;
  private:
  bool _internal_has_linearacceleration() const;
  public:
  void clear_linearacceleration();
  const ::std_msgs::Vector3f& linearacceleration() const;
  PROTOBUF_NODISCARD ::std_msgs::Vector3f* release_linearacceleration();
  ::std_msgs::Vector3f* mutable_linearacceleration();
  void set_allocated_linearacceleration(::std_msgs::Vector3f* linearacceleration);
  private:
  const ::std_msgs::Vector3f& _internal_linearacceleration() const;
  ::std_msgs::Vector3f* _internal_mutable_linearacceleration();
  public:
  void unsafe_arena_set_allocated_linearacceleration(
      ::std_msgs::Vector3f* linearacceleration);
  ::std_msgs::Vector3f* unsafe_arena_release_linearacceleration();

  // .std_msgs.Vector3f magnetometerData = 4;
  bool has_magnetometerdata() const;
  private:
  bool _internal_has_magnetometerdata() const;
  public:
  void clear_magnetometerdata();
  const ::std_msgs::Vector3f& magnetometerdata() const;
  PROTOBUF_NODISCARD ::std_msgs::Vector3f* release_magnetometerdata();
  ::std_msgs::Vector3f* mutable_magnetometerdata();
  void set_allocated_magnetometerdata(::std_msgs::Vector3f* magnetometerdata);
  private:
  const ::std_msgs::Vector3f& _internal_magnetometerdata() const;
  ::std_msgs::Vector3f* _internal_mutable_magnetometerdata();
  public:
  void unsafe_arena_set_allocated_magnetometerdata(
      ::std_msgs::Vector3f* magnetometerdata);
  ::std_msgs::Vector3f* unsafe_arena_release_magnetometerdata();

  // .std_msgs.Vector3f euler = 5;
  bool has_euler() const;
  private:
  bool _internal_has_euler() const;
  public:
  void clear_euler();
  const ::std_msgs::Vector3f& euler() const;
  PROTOBUF_NODISCARD ::std_msgs::Vector3f* release_euler();
  ::std_msgs::Vector3f* mutable_euler();
  void set_allocated_euler(::std_msgs::Vector3f* euler);
  private:
  const ::std_msgs::Vector3f& _internal_euler() const;
  ::std_msgs::Vector3f* _internal_mutable_euler();
  public:
  void unsafe_arena_set_allocated_euler(
      ::std_msgs::Vector3f* euler);
  ::std_msgs::Vector3f* unsafe_arena_release_euler();

  // .std_msgs.Quaternionf orientation = 6;
  bool has_orientation() const;
  private:
  bool _internal_has_orientation() const;
  public:
  void clear_orientation();
  const ::std_msgs::Quaternionf& orientation() const;
  PROTOBUF_NODISCARD ::std_msgs::Quaternionf* release_orientation();
  ::std_msgs::Quaternionf* mutable_orientation();
  void set_allocated_orientation(::std_msgs::Quaternionf* orientation);
  private:
  const ::std_msgs::Quaternionf& _internal_orientation() const;
  ::std_msgs::Quaternionf* _internal_mutable_orientation();
  public:
  void unsafe_arena_set_allocated_orientation(
      ::std_msgs::Quaternionf* orientation);
  ::std_msgs::Quaternionf* unsafe_arena_release_orientation();

  // @@protoc_insertion_point(class_scope:sensor_msgs.Imu)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::std_msgs::Header* header_;
    ::std_msgs::Vector3f* angularvelocity_;
    ::std_msgs::Vector3f* linearacceleration_;
    ::std_msgs::Vector3f* magnetometerdata_;
    ::std_msgs::Vector3f* euler_;
    ::std_msgs::Quaternionf* orientation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensor_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class Odometry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensor_msgs.Odometry) */ {
 public:
  inline Odometry() : Odometry(nullptr) {}
  ~Odometry() override;
  explicit PROTOBUF_CONSTEXPR Odometry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Odometry(const Odometry& from);
  Odometry(Odometry&& from) noexcept
    : Odometry() {
    *this = ::std::move(from);
  }

  inline Odometry& operator=(const Odometry& from) {
    CopyFrom(from);
    return *this;
  }
  inline Odometry& operator=(Odometry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Odometry& default_instance() {
    return *internal_default_instance();
  }
  static inline const Odometry* internal_default_instance() {
    return reinterpret_cast<const Odometry*>(
               &_Odometry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Odometry& a, Odometry& b) {
    a.Swap(&b);
  }
  inline void Swap(Odometry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Odometry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Odometry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Odometry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Odometry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Odometry& from) {
    Odometry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Odometry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensor_msgs.Odometry";
  }
  protected:
  explicit Odometry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildFrameIdFieldNumber = 2,
    kHeaderFieldNumber = 1,
    kPositionFieldNumber = 3,
    kAngularFieldNumber = 4,
    kLinearAccelerationFieldNumber = 5,
    kAngularVelocityFieldNumber = 6,
  };
  // string childFrameId = 2;
  void clear_childframeid();
  const std::string& childframeid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_childframeid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_childframeid();
  PROTOBUF_NODISCARD std::string* release_childframeid();
  void set_allocated_childframeid(std::string* childframeid);
  private:
  const std::string& _internal_childframeid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_childframeid(const std::string& value);
  std::string* _internal_mutable_childframeid();
  public:

  // .std_msgs.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::std_msgs::Header& header() const;
  PROTOBUF_NODISCARD ::std_msgs::Header* release_header();
  ::std_msgs::Header* mutable_header();
  void set_allocated_header(::std_msgs::Header* header);
  private:
  const ::std_msgs::Header& _internal_header() const;
  ::std_msgs::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::std_msgs::Header* header);
  ::std_msgs::Header* unsafe_arena_release_header();

  // .std_msgs.Vector3f position = 3;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::std_msgs::Vector3f& position() const;
  PROTOBUF_NODISCARD ::std_msgs::Vector3f* release_position();
  ::std_msgs::Vector3f* mutable_position();
  void set_allocated_position(::std_msgs::Vector3f* position);
  private:
  const ::std_msgs::Vector3f& _internal_position() const;
  ::std_msgs::Vector3f* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::std_msgs::Vector3f* position);
  ::std_msgs::Vector3f* unsafe_arena_release_position();

  // .std_msgs.Vector3f angular = 4;
  bool has_angular() const;
  private:
  bool _internal_has_angular() const;
  public:
  void clear_angular();
  const ::std_msgs::Vector3f& angular() const;
  PROTOBUF_NODISCARD ::std_msgs::Vector3f* release_angular();
  ::std_msgs::Vector3f* mutable_angular();
  void set_allocated_angular(::std_msgs::Vector3f* angular);
  private:
  const ::std_msgs::Vector3f& _internal_angular() const;
  ::std_msgs::Vector3f* _internal_mutable_angular();
  public:
  void unsafe_arena_set_allocated_angular(
      ::std_msgs::Vector3f* angular);
  ::std_msgs::Vector3f* unsafe_arena_release_angular();

  // .std_msgs.Vector3f linearAcceleration = 5;
  bool has_linearacceleration() const;
  private:
  bool _internal_has_linearacceleration() const;
  public:
  void clear_linearacceleration();
  const ::std_msgs::Vector3f& linearacceleration() const;
  PROTOBUF_NODISCARD ::std_msgs::Vector3f* release_linearacceleration();
  ::std_msgs::Vector3f* mutable_linearacceleration();
  void set_allocated_linearacceleration(::std_msgs::Vector3f* linearacceleration);
  private:
  const ::std_msgs::Vector3f& _internal_linearacceleration() const;
  ::std_msgs::Vector3f* _internal_mutable_linearacceleration();
  public:
  void unsafe_arena_set_allocated_linearacceleration(
      ::std_msgs::Vector3f* linearacceleration);
  ::std_msgs::Vector3f* unsafe_arena_release_linearacceleration();

  // .std_msgs.Vector3f angularVelocity = 6;
  bool has_angularvelocity() const;
  private:
  bool _internal_has_angularvelocity() const;
  public:
  void clear_angularvelocity();
  const ::std_msgs::Vector3f& angularvelocity() const;
  PROTOBUF_NODISCARD ::std_msgs::Vector3f* release_angularvelocity();
  ::std_msgs::Vector3f* mutable_angularvelocity();
  void set_allocated_angularvelocity(::std_msgs::Vector3f* angularvelocity);
  private:
  const ::std_msgs::Vector3f& _internal_angularvelocity() const;
  ::std_msgs::Vector3f* _internal_mutable_angularvelocity();
  public:
  void unsafe_arena_set_allocated_angularvelocity(
      ::std_msgs::Vector3f* angularvelocity);
  ::std_msgs::Vector3f* unsafe_arena_release_angularvelocity();

  // @@protoc_insertion_point(class_scope:sensor_msgs.Odometry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr childframeid_;
    ::std_msgs::Header* header_;
    ::std_msgs::Vector3f* position_;
    ::std_msgs::Vector3f* angular_;
    ::std_msgs::Vector3f* linearacceleration_;
    ::std_msgs::Vector3f* angularvelocity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensor_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class OccupancyMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensor_msgs.OccupancyMap) */ {
 public:
  inline OccupancyMap() : OccupancyMap(nullptr) {}
  ~OccupancyMap() override;
  explicit PROTOBUF_CONSTEXPR OccupancyMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OccupancyMap(const OccupancyMap& from);
  OccupancyMap(OccupancyMap&& from) noexcept
    : OccupancyMap() {
    *this = ::std::move(from);
  }

  inline OccupancyMap& operator=(const OccupancyMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline OccupancyMap& operator=(OccupancyMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OccupancyMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const OccupancyMap* internal_default_instance() {
    return reinterpret_cast<const OccupancyMap*>(
               &_OccupancyMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(OccupancyMap& a, OccupancyMap& b) {
    a.Swap(&b);
  }
  inline void Swap(OccupancyMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OccupancyMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OccupancyMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OccupancyMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OccupancyMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OccupancyMap& from) {
    OccupancyMap::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OccupancyMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensor_msgs.OccupancyMap";
  }
  protected:
  explicit OccupancyMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 7,
    kHeaderFieldNumber = 1,
    kResolutionFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
    kOriginXFieldNumber = 5,
    kOriginYFieldNumber = 6,
  };
  // repeated int32 data = 7;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  int32_t _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_data() const;
  void _internal_add_data(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_data();
  public:
  int32_t data(int index) const;
  void set_data(int index, int32_t value);
  void add_data(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_data();

  // .std_msgs.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::std_msgs::Header& header() const;
  PROTOBUF_NODISCARD ::std_msgs::Header* release_header();
  ::std_msgs::Header* mutable_header();
  void set_allocated_header(::std_msgs::Header* header);
  private:
  const ::std_msgs::Header& _internal_header() const;
  ::std_msgs::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::std_msgs::Header* header);
  ::std_msgs::Header* unsafe_arena_release_header();

  // float resolution = 2;
  void clear_resolution();
  float resolution() const;
  void set_resolution(float value);
  private:
  float _internal_resolution() const;
  void _internal_set_resolution(float value);
  public:

  // int32 width = 3;
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // int32 height = 4;
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // float origin_x = 5;
  void clear_origin_x();
  float origin_x() const;
  void set_origin_x(float value);
  private:
  float _internal_origin_x() const;
  void _internal_set_origin_x(float value);
  public:

  // float origin_y = 6;
  void clear_origin_y();
  float origin_y() const;
  void set_origin_y(float value);
  private:
  float _internal_origin_y() const;
  void _internal_set_origin_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:sensor_msgs.OccupancyMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > data_;
    mutable std::atomic<int> _data_cached_byte_size_;
    ::std_msgs::Header* header_;
    float resolution_;
    int32_t width_;
    int32_t height_;
    float origin_x_;
    float origin_y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensor_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class ESDFMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensor_msgs.ESDFMap) */ {
 public:
  inline ESDFMap() : ESDFMap(nullptr) {}
  ~ESDFMap() override;
  explicit PROTOBUF_CONSTEXPR ESDFMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESDFMap(const ESDFMap& from);
  ESDFMap(ESDFMap&& from) noexcept
    : ESDFMap() {
    *this = ::std::move(from);
  }

  inline ESDFMap& operator=(const ESDFMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESDFMap& operator=(ESDFMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ESDFMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESDFMap* internal_default_instance() {
    return reinterpret_cast<const ESDFMap*>(
               &_ESDFMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ESDFMap& a, ESDFMap& b) {
    a.Swap(&b);
  }
  inline void Swap(ESDFMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESDFMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESDFMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESDFMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ESDFMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ESDFMap& from) {
    ESDFMap::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESDFMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensor_msgs.ESDFMap";
  }
  protected:
  explicit ESDFMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .std_msgs.Vector4f points = 2;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::std_msgs::Vector4f* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::std_msgs::Vector4f >*
      mutable_points();
  private:
  const ::std_msgs::Vector4f& _internal_points(int index) const;
  ::std_msgs::Vector4f* _internal_add_points();
  public:
  const ::std_msgs::Vector4f& points(int index) const;
  ::std_msgs::Vector4f* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::std_msgs::Vector4f >&
      points() const;

  // .std_msgs.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::std_msgs::Header& header() const;
  PROTOBUF_NODISCARD ::std_msgs::Header* release_header();
  ::std_msgs::Header* mutable_header();
  void set_allocated_header(::std_msgs::Header* header);
  private:
  const ::std_msgs::Header& _internal_header() const;
  ::std_msgs::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::std_msgs::Header* header);
  ::std_msgs::Header* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:sensor_msgs.ESDFMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::std_msgs::Vector4f > points_;
    ::std_msgs::Header* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensor_5fmsgs_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Twist2D

// float v_x = 1;
inline void Twist2D::clear_v_x() {
  _impl_.v_x_ = 0;
}
inline float Twist2D::_internal_v_x() const {
  return _impl_.v_x_;
}
inline float Twist2D::v_x() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.Twist2D.v_x)
  return _internal_v_x();
}
inline void Twist2D::_internal_set_v_x(float value) {
  
  _impl_.v_x_ = value;
}
inline void Twist2D::set_v_x(float value) {
  _internal_set_v_x(value);
  // @@protoc_insertion_point(field_set:sensor_msgs.Twist2D.v_x)
}

// float v_y = 2;
inline void Twist2D::clear_v_y() {
  _impl_.v_y_ = 0;
}
inline float Twist2D::_internal_v_y() const {
  return _impl_.v_y_;
}
inline float Twist2D::v_y() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.Twist2D.v_y)
  return _internal_v_y();
}
inline void Twist2D::_internal_set_v_y(float value) {
  
  _impl_.v_y_ = value;
}
inline void Twist2D::set_v_y(float value) {
  _internal_set_v_y(value);
  // @@protoc_insertion_point(field_set:sensor_msgs.Twist2D.v_y)
}

// float omega = 3;
inline void Twist2D::clear_omega() {
  _impl_.omega_ = 0;
}
inline float Twist2D::_internal_omega() const {
  return _impl_.omega_;
}
inline float Twist2D::omega() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.Twist2D.omega)
  return _internal_omega();
}
inline void Twist2D::_internal_set_omega(float value) {
  
  _impl_.omega_ = value;
}
inline void Twist2D::set_omega(float value) {
  _internal_set_omega(value);
  // @@protoc_insertion_point(field_set:sensor_msgs.Twist2D.omega)
}

// -------------------------------------------------------------------

// Twist2DStamp

// .std_msgs.Header header = 1;
inline bool Twist2DStamp::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool Twist2DStamp::has_header() const {
  return _internal_has_header();
}
inline const ::std_msgs::Header& Twist2DStamp::_internal_header() const {
  const ::std_msgs::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msgs::Header&>(
      ::std_msgs::_Header_default_instance_);
}
inline const ::std_msgs::Header& Twist2DStamp::header() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.Twist2DStamp.header)
  return _internal_header();
}
inline void Twist2DStamp::unsafe_arena_set_allocated_header(
    ::std_msgs::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensor_msgs.Twist2DStamp.header)
}
inline ::std_msgs::Header* Twist2DStamp::release_header() {
  
  ::std_msgs::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::std_msgs::Header* Twist2DStamp::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:sensor_msgs.Twist2DStamp.header)
  
  ::std_msgs::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::std_msgs::Header* Twist2DStamp::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msgs::Header>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::std_msgs::Header* Twist2DStamp::mutable_header() {
  ::std_msgs::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:sensor_msgs.Twist2DStamp.header)
  return _msg;
}
inline void Twist2DStamp::set_allocated_header(::std_msgs::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:sensor_msgs.Twist2DStamp.header)
}

// .sensor_msgs.Twist2D twist = 2;
inline bool Twist2DStamp::_internal_has_twist() const {
  return this != internal_default_instance() && _impl_.twist_ != nullptr;
}
inline bool Twist2DStamp::has_twist() const {
  return _internal_has_twist();
}
inline void Twist2DStamp::clear_twist() {
  if (GetArenaForAllocation() == nullptr && _impl_.twist_ != nullptr) {
    delete _impl_.twist_;
  }
  _impl_.twist_ = nullptr;
}
inline const ::sensor_msgs::Twist2D& Twist2DStamp::_internal_twist() const {
  const ::sensor_msgs::Twist2D* p = _impl_.twist_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensor_msgs::Twist2D&>(
      ::sensor_msgs::_Twist2D_default_instance_);
}
inline const ::sensor_msgs::Twist2D& Twist2DStamp::twist() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.Twist2DStamp.twist)
  return _internal_twist();
}
inline void Twist2DStamp::unsafe_arena_set_allocated_twist(
    ::sensor_msgs::Twist2D* twist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.twist_);
  }
  _impl_.twist_ = twist;
  if (twist) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensor_msgs.Twist2DStamp.twist)
}
inline ::sensor_msgs::Twist2D* Twist2DStamp::release_twist() {
  
  ::sensor_msgs::Twist2D* temp = _impl_.twist_;
  _impl_.twist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensor_msgs::Twist2D* Twist2DStamp::unsafe_arena_release_twist() {
  // @@protoc_insertion_point(field_release:sensor_msgs.Twist2DStamp.twist)
  
  ::sensor_msgs::Twist2D* temp = _impl_.twist_;
  _impl_.twist_ = nullptr;
  return temp;
}
inline ::sensor_msgs::Twist2D* Twist2DStamp::_internal_mutable_twist() {
  
  if (_impl_.twist_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensor_msgs::Twist2D>(GetArenaForAllocation());
    _impl_.twist_ = p;
  }
  return _impl_.twist_;
}
inline ::sensor_msgs::Twist2D* Twist2DStamp::mutable_twist() {
  ::sensor_msgs::Twist2D* _msg = _internal_mutable_twist();
  // @@protoc_insertion_point(field_mutable:sensor_msgs.Twist2DStamp.twist)
  return _msg;
}
inline void Twist2DStamp::set_allocated_twist(::sensor_msgs::Twist2D* twist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.twist_;
  }
  if (twist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(twist);
    if (message_arena != submessage_arena) {
      twist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, twist, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.twist_ = twist;
  // @@protoc_insertion_point(field_set_allocated:sensor_msgs.Twist2DStamp.twist)
}

// -------------------------------------------------------------------

// PointCloud2f

// .std_msgs.Header header = 1;
inline bool PointCloud2f::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool PointCloud2f::has_header() const {
  return _internal_has_header();
}
inline const ::std_msgs::Header& PointCloud2f::_internal_header() const {
  const ::std_msgs::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msgs::Header&>(
      ::std_msgs::_Header_default_instance_);
}
inline const ::std_msgs::Header& PointCloud2f::header() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.PointCloud2f.header)
  return _internal_header();
}
inline void PointCloud2f::unsafe_arena_set_allocated_header(
    ::std_msgs::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensor_msgs.PointCloud2f.header)
}
inline ::std_msgs::Header* PointCloud2f::release_header() {
  
  ::std_msgs::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::std_msgs::Header* PointCloud2f::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:sensor_msgs.PointCloud2f.header)
  
  ::std_msgs::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::std_msgs::Header* PointCloud2f::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msgs::Header>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::std_msgs::Header* PointCloud2f::mutable_header() {
  ::std_msgs::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:sensor_msgs.PointCloud2f.header)
  return _msg;
}
inline void PointCloud2f::set_allocated_header(::std_msgs::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:sensor_msgs.PointCloud2f.header)
}

// .std_msgs.Vector2f points = 2;
inline bool PointCloud2f::_internal_has_points() const {
  return this != internal_default_instance() && _impl_.points_ != nullptr;
}
inline bool PointCloud2f::has_points() const {
  return _internal_has_points();
}
inline const ::std_msgs::Vector2f& PointCloud2f::_internal_points() const {
  const ::std_msgs::Vector2f* p = _impl_.points_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msgs::Vector2f&>(
      ::std_msgs::_Vector2f_default_instance_);
}
inline const ::std_msgs::Vector2f& PointCloud2f::points() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.PointCloud2f.points)
  return _internal_points();
}
inline void PointCloud2f::unsafe_arena_set_allocated_points(
    ::std_msgs::Vector2f* points) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.points_);
  }
  _impl_.points_ = points;
  if (points) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensor_msgs.PointCloud2f.points)
}
inline ::std_msgs::Vector2f* PointCloud2f::release_points() {
  
  ::std_msgs::Vector2f* temp = _impl_.points_;
  _impl_.points_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::std_msgs::Vector2f* PointCloud2f::unsafe_arena_release_points() {
  // @@protoc_insertion_point(field_release:sensor_msgs.PointCloud2f.points)
  
  ::std_msgs::Vector2f* temp = _impl_.points_;
  _impl_.points_ = nullptr;
  return temp;
}
inline ::std_msgs::Vector2f* PointCloud2f::_internal_mutable_points() {
  
  if (_impl_.points_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msgs::Vector2f>(GetArenaForAllocation());
    _impl_.points_ = p;
  }
  return _impl_.points_;
}
inline ::std_msgs::Vector2f* PointCloud2f::mutable_points() {
  ::std_msgs::Vector2f* _msg = _internal_mutable_points();
  // @@protoc_insertion_point(field_mutable:sensor_msgs.PointCloud2f.points)
  return _msg;
}
inline void PointCloud2f::set_allocated_points(::std_msgs::Vector2f* points) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.points_);
  }
  if (points) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(points));
    if (message_arena != submessage_arena) {
      points = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, points, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.points_ = points;
  // @@protoc_insertion_point(field_set_allocated:sensor_msgs.PointCloud2f.points)
}

// -------------------------------------------------------------------

// PointCloud3f

// .std_msgs.Header header = 1;
inline bool PointCloud3f::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool PointCloud3f::has_header() const {
  return _internal_has_header();
}
inline const ::std_msgs::Header& PointCloud3f::_internal_header() const {
  const ::std_msgs::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msgs::Header&>(
      ::std_msgs::_Header_default_instance_);
}
inline const ::std_msgs::Header& PointCloud3f::header() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.PointCloud3f.header)
  return _internal_header();
}
inline void PointCloud3f::unsafe_arena_set_allocated_header(
    ::std_msgs::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensor_msgs.PointCloud3f.header)
}
inline ::std_msgs::Header* PointCloud3f::release_header() {
  
  ::std_msgs::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::std_msgs::Header* PointCloud3f::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:sensor_msgs.PointCloud3f.header)
  
  ::std_msgs::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::std_msgs::Header* PointCloud3f::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msgs::Header>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::std_msgs::Header* PointCloud3f::mutable_header() {
  ::std_msgs::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:sensor_msgs.PointCloud3f.header)
  return _msg;
}
inline void PointCloud3f::set_allocated_header(::std_msgs::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:sensor_msgs.PointCloud3f.header)
}

// .std_msgs.Vector3f points = 2;
inline bool PointCloud3f::_internal_has_points() const {
  return this != internal_default_instance() && _impl_.points_ != nullptr;
}
inline bool PointCloud3f::has_points() const {
  return _internal_has_points();
}
inline const ::std_msgs::Vector3f& PointCloud3f::_internal_points() const {
  const ::std_msgs::Vector3f* p = _impl_.points_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msgs::Vector3f&>(
      ::std_msgs::_Vector3f_default_instance_);
}
inline const ::std_msgs::Vector3f& PointCloud3f::points() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.PointCloud3f.points)
  return _internal_points();
}
inline void PointCloud3f::unsafe_arena_set_allocated_points(
    ::std_msgs::Vector3f* points) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.points_);
  }
  _impl_.points_ = points;
  if (points) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensor_msgs.PointCloud3f.points)
}
inline ::std_msgs::Vector3f* PointCloud3f::release_points() {
  
  ::std_msgs::Vector3f* temp = _impl_.points_;
  _impl_.points_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::std_msgs::Vector3f* PointCloud3f::unsafe_arena_release_points() {
  // @@protoc_insertion_point(field_release:sensor_msgs.PointCloud3f.points)
  
  ::std_msgs::Vector3f* temp = _impl_.points_;
  _impl_.points_ = nullptr;
  return temp;
}
inline ::std_msgs::Vector3f* PointCloud3f::_internal_mutable_points() {
  
  if (_impl_.points_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msgs::Vector3f>(GetArenaForAllocation());
    _impl_.points_ = p;
  }
  return _impl_.points_;
}
inline ::std_msgs::Vector3f* PointCloud3f::mutable_points() {
  ::std_msgs::Vector3f* _msg = _internal_mutable_points();
  // @@protoc_insertion_point(field_mutable:sensor_msgs.PointCloud3f.points)
  return _msg;
}
inline void PointCloud3f::set_allocated_points(::std_msgs::Vector3f* points) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.points_);
  }
  if (points) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(points));
    if (message_arena != submessage_arena) {
      points = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, points, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.points_ = points;
  // @@protoc_insertion_point(field_set_allocated:sensor_msgs.PointCloud3f.points)
}

// -------------------------------------------------------------------

// LaserScan

// .std_msgs.Header header = 1;
inline bool LaserScan::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool LaserScan::has_header() const {
  return _internal_has_header();
}
inline const ::std_msgs::Header& LaserScan::_internal_header() const {
  const ::std_msgs::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msgs::Header&>(
      ::std_msgs::_Header_default_instance_);
}
inline const ::std_msgs::Header& LaserScan::header() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.LaserScan.header)
  return _internal_header();
}
inline void LaserScan::unsafe_arena_set_allocated_header(
    ::std_msgs::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensor_msgs.LaserScan.header)
}
inline ::std_msgs::Header* LaserScan::release_header() {
  
  ::std_msgs::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::std_msgs::Header* LaserScan::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:sensor_msgs.LaserScan.header)
  
  ::std_msgs::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::std_msgs::Header* LaserScan::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msgs::Header>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::std_msgs::Header* LaserScan::mutable_header() {
  ::std_msgs::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:sensor_msgs.LaserScan.header)
  return _msg;
}
inline void LaserScan::set_allocated_header(::std_msgs::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:sensor_msgs.LaserScan.header)
}

// float angleMin = 2;
inline void LaserScan::clear_anglemin() {
  _impl_.anglemin_ = 0;
}
inline float LaserScan::_internal_anglemin() const {
  return _impl_.anglemin_;
}
inline float LaserScan::anglemin() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.LaserScan.angleMin)
  return _internal_anglemin();
}
inline void LaserScan::_internal_set_anglemin(float value) {
  
  _impl_.anglemin_ = value;
}
inline void LaserScan::set_anglemin(float value) {
  _internal_set_anglemin(value);
  // @@protoc_insertion_point(field_set:sensor_msgs.LaserScan.angleMin)
}

// float angleMax = 3;
inline void LaserScan::clear_anglemax() {
  _impl_.anglemax_ = 0;
}
inline float LaserScan::_internal_anglemax() const {
  return _impl_.anglemax_;
}
inline float LaserScan::anglemax() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.LaserScan.angleMax)
  return _internal_anglemax();
}
inline void LaserScan::_internal_set_anglemax(float value) {
  
  _impl_.anglemax_ = value;
}
inline void LaserScan::set_anglemax(float value) {
  _internal_set_anglemax(value);
  // @@protoc_insertion_point(field_set:sensor_msgs.LaserScan.angleMax)
}

// float angleIncrement = 4;
inline void LaserScan::clear_angleincrement() {
  _impl_.angleincrement_ = 0;
}
inline float LaserScan::_internal_angleincrement() const {
  return _impl_.angleincrement_;
}
inline float LaserScan::angleincrement() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.LaserScan.angleIncrement)
  return _internal_angleincrement();
}
inline void LaserScan::_internal_set_angleincrement(float value) {
  
  _impl_.angleincrement_ = value;
}
inline void LaserScan::set_angleincrement(float value) {
  _internal_set_angleincrement(value);
  // @@protoc_insertion_point(field_set:sensor_msgs.LaserScan.angleIncrement)
}

// float timeIncrement = 5;
inline void LaserScan::clear_timeincrement() {
  _impl_.timeincrement_ = 0;
}
inline float LaserScan::_internal_timeincrement() const {
  return _impl_.timeincrement_;
}
inline float LaserScan::timeincrement() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.LaserScan.timeIncrement)
  return _internal_timeincrement();
}
inline void LaserScan::_internal_set_timeincrement(float value) {
  
  _impl_.timeincrement_ = value;
}
inline void LaserScan::set_timeincrement(float value) {
  _internal_set_timeincrement(value);
  // @@protoc_insertion_point(field_set:sensor_msgs.LaserScan.timeIncrement)
}

// float scanTime = 6;
inline void LaserScan::clear_scantime() {
  _impl_.scantime_ = 0;
}
inline float LaserScan::_internal_scantime() const {
  return _impl_.scantime_;
}
inline float LaserScan::scantime() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.LaserScan.scanTime)
  return _internal_scantime();
}
inline void LaserScan::_internal_set_scantime(float value) {
  
  _impl_.scantime_ = value;
}
inline void LaserScan::set_scantime(float value) {
  _internal_set_scantime(value);
  // @@protoc_insertion_point(field_set:sensor_msgs.LaserScan.scanTime)
}

// float rangeMin = 7;
inline void LaserScan::clear_rangemin() {
  _impl_.rangemin_ = 0;
}
inline float LaserScan::_internal_rangemin() const {
  return _impl_.rangemin_;
}
inline float LaserScan::rangemin() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.LaserScan.rangeMin)
  return _internal_rangemin();
}
inline void LaserScan::_internal_set_rangemin(float value) {
  
  _impl_.rangemin_ = value;
}
inline void LaserScan::set_rangemin(float value) {
  _internal_set_rangemin(value);
  // @@protoc_insertion_point(field_set:sensor_msgs.LaserScan.rangeMin)
}

// float rangeMax = 8;
inline void LaserScan::clear_rangemax() {
  _impl_.rangemax_ = 0;
}
inline float LaserScan::_internal_rangemax() const {
  return _impl_.rangemax_;
}
inline float LaserScan::rangemax() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.LaserScan.rangeMax)
  return _internal_rangemax();
}
inline void LaserScan::_internal_set_rangemax(float value) {
  
  _impl_.rangemax_ = value;
}
inline void LaserScan::set_rangemax(float value) {
  _internal_set_rangemax(value);
  // @@protoc_insertion_point(field_set:sensor_msgs.LaserScan.rangeMax)
}

// repeated float ranges = 9;
inline int LaserScan::_internal_ranges_size() const {
  return _impl_.ranges_.size();
}
inline int LaserScan::ranges_size() const {
  return _internal_ranges_size();
}
inline void LaserScan::clear_ranges() {
  _impl_.ranges_.Clear();
}
inline float LaserScan::_internal_ranges(int index) const {
  return _impl_.ranges_.Get(index);
}
inline float LaserScan::ranges(int index) const {
  // @@protoc_insertion_point(field_get:sensor_msgs.LaserScan.ranges)
  return _internal_ranges(index);
}
inline void LaserScan::set_ranges(int index, float value) {
  _impl_.ranges_.Set(index, value);
  // @@protoc_insertion_point(field_set:sensor_msgs.LaserScan.ranges)
}
inline void LaserScan::_internal_add_ranges(float value) {
  _impl_.ranges_.Add(value);
}
inline void LaserScan::add_ranges(float value) {
  _internal_add_ranges(value);
  // @@protoc_insertion_point(field_add:sensor_msgs.LaserScan.ranges)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
LaserScan::_internal_ranges() const {
  return _impl_.ranges_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
LaserScan::ranges() const {
  // @@protoc_insertion_point(field_list:sensor_msgs.LaserScan.ranges)
  return _internal_ranges();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
LaserScan::_internal_mutable_ranges() {
  return &_impl_.ranges_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
LaserScan::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:sensor_msgs.LaserScan.ranges)
  return _internal_mutable_ranges();
}

// repeated float intensities = 10;
inline int LaserScan::_internal_intensities_size() const {
  return _impl_.intensities_.size();
}
inline int LaserScan::intensities_size() const {
  return _internal_intensities_size();
}
inline void LaserScan::clear_intensities() {
  _impl_.intensities_.Clear();
}
inline float LaserScan::_internal_intensities(int index) const {
  return _impl_.intensities_.Get(index);
}
inline float LaserScan::intensities(int index) const {
  // @@protoc_insertion_point(field_get:sensor_msgs.LaserScan.intensities)
  return _internal_intensities(index);
}
inline void LaserScan::set_intensities(int index, float value) {
  _impl_.intensities_.Set(index, value);
  // @@protoc_insertion_point(field_set:sensor_msgs.LaserScan.intensities)
}
inline void LaserScan::_internal_add_intensities(float value) {
  _impl_.intensities_.Add(value);
}
inline void LaserScan::add_intensities(float value) {
  _internal_add_intensities(value);
  // @@protoc_insertion_point(field_add:sensor_msgs.LaserScan.intensities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
LaserScan::_internal_intensities() const {
  return _impl_.intensities_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
LaserScan::intensities() const {
  // @@protoc_insertion_point(field_list:sensor_msgs.LaserScan.intensities)
  return _internal_intensities();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
LaserScan::_internal_mutable_intensities() {
  return &_impl_.intensities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
LaserScan::mutable_intensities() {
  // @@protoc_insertion_point(field_mutable_list:sensor_msgs.LaserScan.intensities)
  return _internal_mutable_intensities();
}

// -------------------------------------------------------------------

// Imu

// .std_msgs.Header header = 1;
inline bool Imu::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool Imu::has_header() const {
  return _internal_has_header();
}
inline const ::std_msgs::Header& Imu::_internal_header() const {
  const ::std_msgs::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msgs::Header&>(
      ::std_msgs::_Header_default_instance_);
}
inline const ::std_msgs::Header& Imu::header() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.Imu.header)
  return _internal_header();
}
inline void Imu::unsafe_arena_set_allocated_header(
    ::std_msgs::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensor_msgs.Imu.header)
}
inline ::std_msgs::Header* Imu::release_header() {
  
  ::std_msgs::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::std_msgs::Header* Imu::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:sensor_msgs.Imu.header)
  
  ::std_msgs::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::std_msgs::Header* Imu::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msgs::Header>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::std_msgs::Header* Imu::mutable_header() {
  ::std_msgs::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:sensor_msgs.Imu.header)
  return _msg;
}
inline void Imu::set_allocated_header(::std_msgs::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:sensor_msgs.Imu.header)
}

// .std_msgs.Vector3f angularVelocity = 2;
inline bool Imu::_internal_has_angularvelocity() const {
  return this != internal_default_instance() && _impl_.angularvelocity_ != nullptr;
}
inline bool Imu::has_angularvelocity() const {
  return _internal_has_angularvelocity();
}
inline const ::std_msgs::Vector3f& Imu::_internal_angularvelocity() const {
  const ::std_msgs::Vector3f* p = _impl_.angularvelocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msgs::Vector3f&>(
      ::std_msgs::_Vector3f_default_instance_);
}
inline const ::std_msgs::Vector3f& Imu::angularvelocity() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.Imu.angularVelocity)
  return _internal_angularvelocity();
}
inline void Imu::unsafe_arena_set_allocated_angularvelocity(
    ::std_msgs::Vector3f* angularvelocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.angularvelocity_);
  }
  _impl_.angularvelocity_ = angularvelocity;
  if (angularvelocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensor_msgs.Imu.angularVelocity)
}
inline ::std_msgs::Vector3f* Imu::release_angularvelocity() {
  
  ::std_msgs::Vector3f* temp = _impl_.angularvelocity_;
  _impl_.angularvelocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::std_msgs::Vector3f* Imu::unsafe_arena_release_angularvelocity() {
  // @@protoc_insertion_point(field_release:sensor_msgs.Imu.angularVelocity)
  
  ::std_msgs::Vector3f* temp = _impl_.angularvelocity_;
  _impl_.angularvelocity_ = nullptr;
  return temp;
}
inline ::std_msgs::Vector3f* Imu::_internal_mutable_angularvelocity() {
  
  if (_impl_.angularvelocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msgs::Vector3f>(GetArenaForAllocation());
    _impl_.angularvelocity_ = p;
  }
  return _impl_.angularvelocity_;
}
inline ::std_msgs::Vector3f* Imu::mutable_angularvelocity() {
  ::std_msgs::Vector3f* _msg = _internal_mutable_angularvelocity();
  // @@protoc_insertion_point(field_mutable:sensor_msgs.Imu.angularVelocity)
  return _msg;
}
inline void Imu::set_allocated_angularvelocity(::std_msgs::Vector3f* angularvelocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.angularvelocity_);
  }
  if (angularvelocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(angularvelocity));
    if (message_arena != submessage_arena) {
      angularvelocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angularvelocity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.angularvelocity_ = angularvelocity;
  // @@protoc_insertion_point(field_set_allocated:sensor_msgs.Imu.angularVelocity)
}

// .std_msgs.Vector3f linearAcceleration = 3;
inline bool Imu::_internal_has_linearacceleration() const {
  return this != internal_default_instance() && _impl_.linearacceleration_ != nullptr;
}
inline bool Imu::has_linearacceleration() const {
  return _internal_has_linearacceleration();
}
inline const ::std_msgs::Vector3f& Imu::_internal_linearacceleration() const {
  const ::std_msgs::Vector3f* p = _impl_.linearacceleration_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msgs::Vector3f&>(
      ::std_msgs::_Vector3f_default_instance_);
}
inline const ::std_msgs::Vector3f& Imu::linearacceleration() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.Imu.linearAcceleration)
  return _internal_linearacceleration();
}
inline void Imu::unsafe_arena_set_allocated_linearacceleration(
    ::std_msgs::Vector3f* linearacceleration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linearacceleration_);
  }
  _impl_.linearacceleration_ = linearacceleration;
  if (linearacceleration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensor_msgs.Imu.linearAcceleration)
}
inline ::std_msgs::Vector3f* Imu::release_linearacceleration() {
  
  ::std_msgs::Vector3f* temp = _impl_.linearacceleration_;
  _impl_.linearacceleration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::std_msgs::Vector3f* Imu::unsafe_arena_release_linearacceleration() {
  // @@protoc_insertion_point(field_release:sensor_msgs.Imu.linearAcceleration)
  
  ::std_msgs::Vector3f* temp = _impl_.linearacceleration_;
  _impl_.linearacceleration_ = nullptr;
  return temp;
}
inline ::std_msgs::Vector3f* Imu::_internal_mutable_linearacceleration() {
  
  if (_impl_.linearacceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msgs::Vector3f>(GetArenaForAllocation());
    _impl_.linearacceleration_ = p;
  }
  return _impl_.linearacceleration_;
}
inline ::std_msgs::Vector3f* Imu::mutable_linearacceleration() {
  ::std_msgs::Vector3f* _msg = _internal_mutable_linearacceleration();
  // @@protoc_insertion_point(field_mutable:sensor_msgs.Imu.linearAcceleration)
  return _msg;
}
inline void Imu::set_allocated_linearacceleration(::std_msgs::Vector3f* linearacceleration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linearacceleration_);
  }
  if (linearacceleration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(linearacceleration));
    if (message_arena != submessage_arena) {
      linearacceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linearacceleration, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.linearacceleration_ = linearacceleration;
  // @@protoc_insertion_point(field_set_allocated:sensor_msgs.Imu.linearAcceleration)
}

// .std_msgs.Vector3f magnetometerData = 4;
inline bool Imu::_internal_has_magnetometerdata() const {
  return this != internal_default_instance() && _impl_.magnetometerdata_ != nullptr;
}
inline bool Imu::has_magnetometerdata() const {
  return _internal_has_magnetometerdata();
}
inline const ::std_msgs::Vector3f& Imu::_internal_magnetometerdata() const {
  const ::std_msgs::Vector3f* p = _impl_.magnetometerdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msgs::Vector3f&>(
      ::std_msgs::_Vector3f_default_instance_);
}
inline const ::std_msgs::Vector3f& Imu::magnetometerdata() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.Imu.magnetometerData)
  return _internal_magnetometerdata();
}
inline void Imu::unsafe_arena_set_allocated_magnetometerdata(
    ::std_msgs::Vector3f* magnetometerdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.magnetometerdata_);
  }
  _impl_.magnetometerdata_ = magnetometerdata;
  if (magnetometerdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensor_msgs.Imu.magnetometerData)
}
inline ::std_msgs::Vector3f* Imu::release_magnetometerdata() {
  
  ::std_msgs::Vector3f* temp = _impl_.magnetometerdata_;
  _impl_.magnetometerdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::std_msgs::Vector3f* Imu::unsafe_arena_release_magnetometerdata() {
  // @@protoc_insertion_point(field_release:sensor_msgs.Imu.magnetometerData)
  
  ::std_msgs::Vector3f* temp = _impl_.magnetometerdata_;
  _impl_.magnetometerdata_ = nullptr;
  return temp;
}
inline ::std_msgs::Vector3f* Imu::_internal_mutable_magnetometerdata() {
  
  if (_impl_.magnetometerdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msgs::Vector3f>(GetArenaForAllocation());
    _impl_.magnetometerdata_ = p;
  }
  return _impl_.magnetometerdata_;
}
inline ::std_msgs::Vector3f* Imu::mutable_magnetometerdata() {
  ::std_msgs::Vector3f* _msg = _internal_mutable_magnetometerdata();
  // @@protoc_insertion_point(field_mutable:sensor_msgs.Imu.magnetometerData)
  return _msg;
}
inline void Imu::set_allocated_magnetometerdata(::std_msgs::Vector3f* magnetometerdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.magnetometerdata_);
  }
  if (magnetometerdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(magnetometerdata));
    if (message_arena != submessage_arena) {
      magnetometerdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, magnetometerdata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.magnetometerdata_ = magnetometerdata;
  // @@protoc_insertion_point(field_set_allocated:sensor_msgs.Imu.magnetometerData)
}

// .std_msgs.Vector3f euler = 5;
inline bool Imu::_internal_has_euler() const {
  return this != internal_default_instance() && _impl_.euler_ != nullptr;
}
inline bool Imu::has_euler() const {
  return _internal_has_euler();
}
inline const ::std_msgs::Vector3f& Imu::_internal_euler() const {
  const ::std_msgs::Vector3f* p = _impl_.euler_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msgs::Vector3f&>(
      ::std_msgs::_Vector3f_default_instance_);
}
inline const ::std_msgs::Vector3f& Imu::euler() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.Imu.euler)
  return _internal_euler();
}
inline void Imu::unsafe_arena_set_allocated_euler(
    ::std_msgs::Vector3f* euler) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.euler_);
  }
  _impl_.euler_ = euler;
  if (euler) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensor_msgs.Imu.euler)
}
inline ::std_msgs::Vector3f* Imu::release_euler() {
  
  ::std_msgs::Vector3f* temp = _impl_.euler_;
  _impl_.euler_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::std_msgs::Vector3f* Imu::unsafe_arena_release_euler() {
  // @@protoc_insertion_point(field_release:sensor_msgs.Imu.euler)
  
  ::std_msgs::Vector3f* temp = _impl_.euler_;
  _impl_.euler_ = nullptr;
  return temp;
}
inline ::std_msgs::Vector3f* Imu::_internal_mutable_euler() {
  
  if (_impl_.euler_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msgs::Vector3f>(GetArenaForAllocation());
    _impl_.euler_ = p;
  }
  return _impl_.euler_;
}
inline ::std_msgs::Vector3f* Imu::mutable_euler() {
  ::std_msgs::Vector3f* _msg = _internal_mutable_euler();
  // @@protoc_insertion_point(field_mutable:sensor_msgs.Imu.euler)
  return _msg;
}
inline void Imu::set_allocated_euler(::std_msgs::Vector3f* euler) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.euler_);
  }
  if (euler) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(euler));
    if (message_arena != submessage_arena) {
      euler = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, euler, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.euler_ = euler;
  // @@protoc_insertion_point(field_set_allocated:sensor_msgs.Imu.euler)
}

// .std_msgs.Quaternionf orientation = 6;
inline bool Imu::_internal_has_orientation() const {
  return this != internal_default_instance() && _impl_.orientation_ != nullptr;
}
inline bool Imu::has_orientation() const {
  return _internal_has_orientation();
}
inline const ::std_msgs::Quaternionf& Imu::_internal_orientation() const {
  const ::std_msgs::Quaternionf* p = _impl_.orientation_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msgs::Quaternionf&>(
      ::std_msgs::_Quaternionf_default_instance_);
}
inline const ::std_msgs::Quaternionf& Imu::orientation() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.Imu.orientation)
  return _internal_orientation();
}
inline void Imu::unsafe_arena_set_allocated_orientation(
    ::std_msgs::Quaternionf* orientation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.orientation_);
  }
  _impl_.orientation_ = orientation;
  if (orientation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensor_msgs.Imu.orientation)
}
inline ::std_msgs::Quaternionf* Imu::release_orientation() {
  
  ::std_msgs::Quaternionf* temp = _impl_.orientation_;
  _impl_.orientation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::std_msgs::Quaternionf* Imu::unsafe_arena_release_orientation() {
  // @@protoc_insertion_point(field_release:sensor_msgs.Imu.orientation)
  
  ::std_msgs::Quaternionf* temp = _impl_.orientation_;
  _impl_.orientation_ = nullptr;
  return temp;
}
inline ::std_msgs::Quaternionf* Imu::_internal_mutable_orientation() {
  
  if (_impl_.orientation_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msgs::Quaternionf>(GetArenaForAllocation());
    _impl_.orientation_ = p;
  }
  return _impl_.orientation_;
}
inline ::std_msgs::Quaternionf* Imu::mutable_orientation() {
  ::std_msgs::Quaternionf* _msg = _internal_mutable_orientation();
  // @@protoc_insertion_point(field_mutable:sensor_msgs.Imu.orientation)
  return _msg;
}
inline void Imu::set_allocated_orientation(::std_msgs::Quaternionf* orientation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.orientation_);
  }
  if (orientation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(orientation));
    if (message_arena != submessage_arena) {
      orientation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orientation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.orientation_ = orientation;
  // @@protoc_insertion_point(field_set_allocated:sensor_msgs.Imu.orientation)
}

// -------------------------------------------------------------------

// Odometry

// .std_msgs.Header header = 1;
inline bool Odometry::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool Odometry::has_header() const {
  return _internal_has_header();
}
inline const ::std_msgs::Header& Odometry::_internal_header() const {
  const ::std_msgs::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msgs::Header&>(
      ::std_msgs::_Header_default_instance_);
}
inline const ::std_msgs::Header& Odometry::header() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.Odometry.header)
  return _internal_header();
}
inline void Odometry::unsafe_arena_set_allocated_header(
    ::std_msgs::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensor_msgs.Odometry.header)
}
inline ::std_msgs::Header* Odometry::release_header() {
  
  ::std_msgs::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::std_msgs::Header* Odometry::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:sensor_msgs.Odometry.header)
  
  ::std_msgs::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::std_msgs::Header* Odometry::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msgs::Header>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::std_msgs::Header* Odometry::mutable_header() {
  ::std_msgs::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:sensor_msgs.Odometry.header)
  return _msg;
}
inline void Odometry::set_allocated_header(::std_msgs::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:sensor_msgs.Odometry.header)
}

// string childFrameId = 2;
inline void Odometry::clear_childframeid() {
  _impl_.childframeid_.ClearToEmpty();
}
inline const std::string& Odometry::childframeid() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.Odometry.childFrameId)
  return _internal_childframeid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Odometry::set_childframeid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.childframeid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensor_msgs.Odometry.childFrameId)
}
inline std::string* Odometry::mutable_childframeid() {
  std::string* _s = _internal_mutable_childframeid();
  // @@protoc_insertion_point(field_mutable:sensor_msgs.Odometry.childFrameId)
  return _s;
}
inline const std::string& Odometry::_internal_childframeid() const {
  return _impl_.childframeid_.Get();
}
inline void Odometry::_internal_set_childframeid(const std::string& value) {
  
  _impl_.childframeid_.Set(value, GetArenaForAllocation());
}
inline std::string* Odometry::_internal_mutable_childframeid() {
  
  return _impl_.childframeid_.Mutable(GetArenaForAllocation());
}
inline std::string* Odometry::release_childframeid() {
  // @@protoc_insertion_point(field_release:sensor_msgs.Odometry.childFrameId)
  return _impl_.childframeid_.Release();
}
inline void Odometry::set_allocated_childframeid(std::string* childframeid) {
  if (childframeid != nullptr) {
    
  } else {
    
  }
  _impl_.childframeid_.SetAllocated(childframeid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.childframeid_.IsDefault()) {
    _impl_.childframeid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sensor_msgs.Odometry.childFrameId)
}

// .std_msgs.Vector3f position = 3;
inline bool Odometry::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool Odometry::has_position() const {
  return _internal_has_position();
}
inline const ::std_msgs::Vector3f& Odometry::_internal_position() const {
  const ::std_msgs::Vector3f* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msgs::Vector3f&>(
      ::std_msgs::_Vector3f_default_instance_);
}
inline const ::std_msgs::Vector3f& Odometry::position() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.Odometry.position)
  return _internal_position();
}
inline void Odometry::unsafe_arena_set_allocated_position(
    ::std_msgs::Vector3f* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensor_msgs.Odometry.position)
}
inline ::std_msgs::Vector3f* Odometry::release_position() {
  
  ::std_msgs::Vector3f* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::std_msgs::Vector3f* Odometry::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:sensor_msgs.Odometry.position)
  
  ::std_msgs::Vector3f* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::std_msgs::Vector3f* Odometry::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msgs::Vector3f>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::std_msgs::Vector3f* Odometry::mutable_position() {
  ::std_msgs::Vector3f* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:sensor_msgs.Odometry.position)
  return _msg;
}
inline void Odometry::set_allocated_position(::std_msgs::Vector3f* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position));
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:sensor_msgs.Odometry.position)
}

// .std_msgs.Vector3f angular = 4;
inline bool Odometry::_internal_has_angular() const {
  return this != internal_default_instance() && _impl_.angular_ != nullptr;
}
inline bool Odometry::has_angular() const {
  return _internal_has_angular();
}
inline const ::std_msgs::Vector3f& Odometry::_internal_angular() const {
  const ::std_msgs::Vector3f* p = _impl_.angular_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msgs::Vector3f&>(
      ::std_msgs::_Vector3f_default_instance_);
}
inline const ::std_msgs::Vector3f& Odometry::angular() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.Odometry.angular)
  return _internal_angular();
}
inline void Odometry::unsafe_arena_set_allocated_angular(
    ::std_msgs::Vector3f* angular) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.angular_);
  }
  _impl_.angular_ = angular;
  if (angular) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensor_msgs.Odometry.angular)
}
inline ::std_msgs::Vector3f* Odometry::release_angular() {
  
  ::std_msgs::Vector3f* temp = _impl_.angular_;
  _impl_.angular_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::std_msgs::Vector3f* Odometry::unsafe_arena_release_angular() {
  // @@protoc_insertion_point(field_release:sensor_msgs.Odometry.angular)
  
  ::std_msgs::Vector3f* temp = _impl_.angular_;
  _impl_.angular_ = nullptr;
  return temp;
}
inline ::std_msgs::Vector3f* Odometry::_internal_mutable_angular() {
  
  if (_impl_.angular_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msgs::Vector3f>(GetArenaForAllocation());
    _impl_.angular_ = p;
  }
  return _impl_.angular_;
}
inline ::std_msgs::Vector3f* Odometry::mutable_angular() {
  ::std_msgs::Vector3f* _msg = _internal_mutable_angular();
  // @@protoc_insertion_point(field_mutable:sensor_msgs.Odometry.angular)
  return _msg;
}
inline void Odometry::set_allocated_angular(::std_msgs::Vector3f* angular) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.angular_);
  }
  if (angular) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(angular));
    if (message_arena != submessage_arena) {
      angular = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angular, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.angular_ = angular;
  // @@protoc_insertion_point(field_set_allocated:sensor_msgs.Odometry.angular)
}

// .std_msgs.Vector3f linearAcceleration = 5;
inline bool Odometry::_internal_has_linearacceleration() const {
  return this != internal_default_instance() && _impl_.linearacceleration_ != nullptr;
}
inline bool Odometry::has_linearacceleration() const {
  return _internal_has_linearacceleration();
}
inline const ::std_msgs::Vector3f& Odometry::_internal_linearacceleration() const {
  const ::std_msgs::Vector3f* p = _impl_.linearacceleration_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msgs::Vector3f&>(
      ::std_msgs::_Vector3f_default_instance_);
}
inline const ::std_msgs::Vector3f& Odometry::linearacceleration() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.Odometry.linearAcceleration)
  return _internal_linearacceleration();
}
inline void Odometry::unsafe_arena_set_allocated_linearacceleration(
    ::std_msgs::Vector3f* linearacceleration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linearacceleration_);
  }
  _impl_.linearacceleration_ = linearacceleration;
  if (linearacceleration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensor_msgs.Odometry.linearAcceleration)
}
inline ::std_msgs::Vector3f* Odometry::release_linearacceleration() {
  
  ::std_msgs::Vector3f* temp = _impl_.linearacceleration_;
  _impl_.linearacceleration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::std_msgs::Vector3f* Odometry::unsafe_arena_release_linearacceleration() {
  // @@protoc_insertion_point(field_release:sensor_msgs.Odometry.linearAcceleration)
  
  ::std_msgs::Vector3f* temp = _impl_.linearacceleration_;
  _impl_.linearacceleration_ = nullptr;
  return temp;
}
inline ::std_msgs::Vector3f* Odometry::_internal_mutable_linearacceleration() {
  
  if (_impl_.linearacceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msgs::Vector3f>(GetArenaForAllocation());
    _impl_.linearacceleration_ = p;
  }
  return _impl_.linearacceleration_;
}
inline ::std_msgs::Vector3f* Odometry::mutable_linearacceleration() {
  ::std_msgs::Vector3f* _msg = _internal_mutable_linearacceleration();
  // @@protoc_insertion_point(field_mutable:sensor_msgs.Odometry.linearAcceleration)
  return _msg;
}
inline void Odometry::set_allocated_linearacceleration(::std_msgs::Vector3f* linearacceleration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linearacceleration_);
  }
  if (linearacceleration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(linearacceleration));
    if (message_arena != submessage_arena) {
      linearacceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linearacceleration, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.linearacceleration_ = linearacceleration;
  // @@protoc_insertion_point(field_set_allocated:sensor_msgs.Odometry.linearAcceleration)
}

// .std_msgs.Vector3f angularVelocity = 6;
inline bool Odometry::_internal_has_angularvelocity() const {
  return this != internal_default_instance() && _impl_.angularvelocity_ != nullptr;
}
inline bool Odometry::has_angularvelocity() const {
  return _internal_has_angularvelocity();
}
inline const ::std_msgs::Vector3f& Odometry::_internal_angularvelocity() const {
  const ::std_msgs::Vector3f* p = _impl_.angularvelocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msgs::Vector3f&>(
      ::std_msgs::_Vector3f_default_instance_);
}
inline const ::std_msgs::Vector3f& Odometry::angularvelocity() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.Odometry.angularVelocity)
  return _internal_angularvelocity();
}
inline void Odometry::unsafe_arena_set_allocated_angularvelocity(
    ::std_msgs::Vector3f* angularvelocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.angularvelocity_);
  }
  _impl_.angularvelocity_ = angularvelocity;
  if (angularvelocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensor_msgs.Odometry.angularVelocity)
}
inline ::std_msgs::Vector3f* Odometry::release_angularvelocity() {
  
  ::std_msgs::Vector3f* temp = _impl_.angularvelocity_;
  _impl_.angularvelocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::std_msgs::Vector3f* Odometry::unsafe_arena_release_angularvelocity() {
  // @@protoc_insertion_point(field_release:sensor_msgs.Odometry.angularVelocity)
  
  ::std_msgs::Vector3f* temp = _impl_.angularvelocity_;
  _impl_.angularvelocity_ = nullptr;
  return temp;
}
inline ::std_msgs::Vector3f* Odometry::_internal_mutable_angularvelocity() {
  
  if (_impl_.angularvelocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msgs::Vector3f>(GetArenaForAllocation());
    _impl_.angularvelocity_ = p;
  }
  return _impl_.angularvelocity_;
}
inline ::std_msgs::Vector3f* Odometry::mutable_angularvelocity() {
  ::std_msgs::Vector3f* _msg = _internal_mutable_angularvelocity();
  // @@protoc_insertion_point(field_mutable:sensor_msgs.Odometry.angularVelocity)
  return _msg;
}
inline void Odometry::set_allocated_angularvelocity(::std_msgs::Vector3f* angularvelocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.angularvelocity_);
  }
  if (angularvelocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(angularvelocity));
    if (message_arena != submessage_arena) {
      angularvelocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angularvelocity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.angularvelocity_ = angularvelocity;
  // @@protoc_insertion_point(field_set_allocated:sensor_msgs.Odometry.angularVelocity)
}

// -------------------------------------------------------------------

// OccupancyMap

// .std_msgs.Header header = 1;
inline bool OccupancyMap::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool OccupancyMap::has_header() const {
  return _internal_has_header();
}
inline const ::std_msgs::Header& OccupancyMap::_internal_header() const {
  const ::std_msgs::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msgs::Header&>(
      ::std_msgs::_Header_default_instance_);
}
inline const ::std_msgs::Header& OccupancyMap::header() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.OccupancyMap.header)
  return _internal_header();
}
inline void OccupancyMap::unsafe_arena_set_allocated_header(
    ::std_msgs::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensor_msgs.OccupancyMap.header)
}
inline ::std_msgs::Header* OccupancyMap::release_header() {
  
  ::std_msgs::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::std_msgs::Header* OccupancyMap::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:sensor_msgs.OccupancyMap.header)
  
  ::std_msgs::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::std_msgs::Header* OccupancyMap::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msgs::Header>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::std_msgs::Header* OccupancyMap::mutable_header() {
  ::std_msgs::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:sensor_msgs.OccupancyMap.header)
  return _msg;
}
inline void OccupancyMap::set_allocated_header(::std_msgs::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:sensor_msgs.OccupancyMap.header)
}

// float resolution = 2;
inline void OccupancyMap::clear_resolution() {
  _impl_.resolution_ = 0;
}
inline float OccupancyMap::_internal_resolution() const {
  return _impl_.resolution_;
}
inline float OccupancyMap::resolution() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.OccupancyMap.resolution)
  return _internal_resolution();
}
inline void OccupancyMap::_internal_set_resolution(float value) {
  
  _impl_.resolution_ = value;
}
inline void OccupancyMap::set_resolution(float value) {
  _internal_set_resolution(value);
  // @@protoc_insertion_point(field_set:sensor_msgs.OccupancyMap.resolution)
}

// int32 width = 3;
inline void OccupancyMap::clear_width() {
  _impl_.width_ = 0;
}
inline int32_t OccupancyMap::_internal_width() const {
  return _impl_.width_;
}
inline int32_t OccupancyMap::width() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.OccupancyMap.width)
  return _internal_width();
}
inline void OccupancyMap::_internal_set_width(int32_t value) {
  
  _impl_.width_ = value;
}
inline void OccupancyMap::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:sensor_msgs.OccupancyMap.width)
}

// int32 height = 4;
inline void OccupancyMap::clear_height() {
  _impl_.height_ = 0;
}
inline int32_t OccupancyMap::_internal_height() const {
  return _impl_.height_;
}
inline int32_t OccupancyMap::height() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.OccupancyMap.height)
  return _internal_height();
}
inline void OccupancyMap::_internal_set_height(int32_t value) {
  
  _impl_.height_ = value;
}
inline void OccupancyMap::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:sensor_msgs.OccupancyMap.height)
}

// float origin_x = 5;
inline void OccupancyMap::clear_origin_x() {
  _impl_.origin_x_ = 0;
}
inline float OccupancyMap::_internal_origin_x() const {
  return _impl_.origin_x_;
}
inline float OccupancyMap::origin_x() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.OccupancyMap.origin_x)
  return _internal_origin_x();
}
inline void OccupancyMap::_internal_set_origin_x(float value) {
  
  _impl_.origin_x_ = value;
}
inline void OccupancyMap::set_origin_x(float value) {
  _internal_set_origin_x(value);
  // @@protoc_insertion_point(field_set:sensor_msgs.OccupancyMap.origin_x)
}

// float origin_y = 6;
inline void OccupancyMap::clear_origin_y() {
  _impl_.origin_y_ = 0;
}
inline float OccupancyMap::_internal_origin_y() const {
  return _impl_.origin_y_;
}
inline float OccupancyMap::origin_y() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.OccupancyMap.origin_y)
  return _internal_origin_y();
}
inline void OccupancyMap::_internal_set_origin_y(float value) {
  
  _impl_.origin_y_ = value;
}
inline void OccupancyMap::set_origin_y(float value) {
  _internal_set_origin_y(value);
  // @@protoc_insertion_point(field_set:sensor_msgs.OccupancyMap.origin_y)
}

// repeated int32 data = 7;
inline int OccupancyMap::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int OccupancyMap::data_size() const {
  return _internal_data_size();
}
inline void OccupancyMap::clear_data() {
  _impl_.data_.Clear();
}
inline int32_t OccupancyMap::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline int32_t OccupancyMap::data(int index) const {
  // @@protoc_insertion_point(field_get:sensor_msgs.OccupancyMap.data)
  return _internal_data(index);
}
inline void OccupancyMap::set_data(int index, int32_t value) {
  _impl_.data_.Set(index, value);
  // @@protoc_insertion_point(field_set:sensor_msgs.OccupancyMap.data)
}
inline void OccupancyMap::_internal_add_data(int32_t value) {
  _impl_.data_.Add(value);
}
inline void OccupancyMap::add_data(int32_t value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:sensor_msgs.OccupancyMap.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
OccupancyMap::_internal_data() const {
  return _impl_.data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
OccupancyMap::data() const {
  // @@protoc_insertion_point(field_list:sensor_msgs.OccupancyMap.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
OccupancyMap::_internal_mutable_data() {
  return &_impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
OccupancyMap::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:sensor_msgs.OccupancyMap.data)
  return _internal_mutable_data();
}

// -------------------------------------------------------------------

// ESDFMap

// .std_msgs.Header header = 1;
inline bool ESDFMap::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ESDFMap::has_header() const {
  return _internal_has_header();
}
inline const ::std_msgs::Header& ESDFMap::_internal_header() const {
  const ::std_msgs::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msgs::Header&>(
      ::std_msgs::_Header_default_instance_);
}
inline const ::std_msgs::Header& ESDFMap::header() const {
  // @@protoc_insertion_point(field_get:sensor_msgs.ESDFMap.header)
  return _internal_header();
}
inline void ESDFMap::unsafe_arena_set_allocated_header(
    ::std_msgs::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensor_msgs.ESDFMap.header)
}
inline ::std_msgs::Header* ESDFMap::release_header() {
  
  ::std_msgs::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::std_msgs::Header* ESDFMap::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:sensor_msgs.ESDFMap.header)
  
  ::std_msgs::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::std_msgs::Header* ESDFMap::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msgs::Header>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::std_msgs::Header* ESDFMap::mutable_header() {
  ::std_msgs::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:sensor_msgs.ESDFMap.header)
  return _msg;
}
inline void ESDFMap::set_allocated_header(::std_msgs::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:sensor_msgs.ESDFMap.header)
}

// repeated .std_msgs.Vector4f points = 2;
inline int ESDFMap::_internal_points_size() const {
  return _impl_.points_.size();
}
inline int ESDFMap::points_size() const {
  return _internal_points_size();
}
inline ::std_msgs::Vector4f* ESDFMap::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:sensor_msgs.ESDFMap.points)
  return _impl_.points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::std_msgs::Vector4f >*
ESDFMap::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:sensor_msgs.ESDFMap.points)
  return &_impl_.points_;
}
inline const ::std_msgs::Vector4f& ESDFMap::_internal_points(int index) const {
  return _impl_.points_.Get(index);
}
inline const ::std_msgs::Vector4f& ESDFMap::points(int index) const {
  // @@protoc_insertion_point(field_get:sensor_msgs.ESDFMap.points)
  return _internal_points(index);
}
inline ::std_msgs::Vector4f* ESDFMap::_internal_add_points() {
  return _impl_.points_.Add();
}
inline ::std_msgs::Vector4f* ESDFMap::add_points() {
  ::std_msgs::Vector4f* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:sensor_msgs.ESDFMap.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::std_msgs::Vector4f >&
ESDFMap::points() const {
  // @@protoc_insertion_point(field_list:sensor_msgs.ESDFMap.points)
  return _impl_.points_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sensor_msgs

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sensor_5fmsgs_2eproto
